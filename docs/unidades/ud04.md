# Unidad 4. Estructuras de datos din치micas

| Fecha      | Versi칩n | Descripci칩n                                                  |
| ---------- | ------- | ------------------------------------------------------------ |
| 15/10/2021 | 1.0.0   | Versi칩n inicial                                              |
| 23/11/2025 | 2.0.0   | **Versi칩n revisada:** Ejemplos funcionales completos y profundizaci칩n en Mapas. |

## 1. Introducci칩n: Limitaciones del Almacenamiento Est치tico

### 1.1. Estructuras Est치ticas (Arrays)

En el desarrollo de software profesional, la gesti칩n de datos rara vez es predecible. Hasta ahora, hemos utilizado **Arrays**, que son estructuras de almacenamiento **est치tico**. Esto implica que su tama침o se define en tiempo de compilaci칩n o inicializaci칩n y no puede modificarse durante la ejecuci칩n.

* **Ventajas:**

    * **Rendimiento extremo:** Acceso directo a memoria y muy ligeros.
    * **Simplicidad:** Ideales cuando sabemos *exactamente* cu치ntos datos vamos a manejar (ej: d칤as de la semana, meses del a침o).

* **El problema del Array:**
  
    * **Rigidez:** Si declaramos `int[] datos = new int[10];`, estamos limitados a 10 elementos. No se pueden redimensionar. Si te quedas corto, el programa falla (`ArrayIndexOutOfBoundsException`).
    * **Ineficiencia:** Si solo usamos 2 posiciones, desperdiciamos memoria reservada para las otras 8.
    * **Complejidad de gesti칩n:** Insertar un elemento en medio requiere mover manualmente todos los elementos posteriores.

En programaci칩n, la forma en que almacenamos y organizamos los datos determina la eficiencia y la flexibilidad de nuestras aplicaciones.

### 1.2. Estructuras Din치micas (Colecciones)

Para resolver estos problemas, Java proporciona el **Java Collection Framework (JCF)**. Este conjunto de clases e interfaces permite gestionar grupos de objetos de forma **din치mica**, adaptando el uso de memoria a las necesidades del programa en tiempo de ejecuci칩n.

* **Ventajas:**
    * **Flexibilidad total:** Crecen y decrecen seg칰n la necesidad.
    * **Potencia:** Incluyen algoritmos ya programados para buscar, ordenar, barajar, invertir, etc.
    * **Abstracci칩n:** Nos olvidamos de la gesti칩n de memoria de bajo nivel.
  
* **Desventajas:**
    * **Mayor consumo de memoria:** Tienen una peque침a sobrecarga (overhead) por ser objetos complejos.
    * **Tipado:** Solo trabajan con Objetos (requieren Wrappers para tipos primitivos), lo que a침ade un peque침칤simo coste de procesamiento.

---

## 2. Java Collection Framework (JCF)

Java no nos deja solos con la tarea de programar estructuras din치micas. Nos ofrece el **Java Collection Framework (JCF)**, una arquitectura unificada para representar y manipular colecciones.

El JCF no es solo "una lista de clases". Es un dise침o de ingenier칤a de software basado en tres pilares:

1. **Interfaces:** Definen **QU칄** se puede hacer (el contrato). Ej: `List`, `Set`, `Map`. Nos permiten programar contra abstracciones (ej: "necesito una Lista", sin importar si es `ArrayList` o `LinkedList`).
2. **Implementaciones:** Son las clases concretas que definen **C칍MO** se hace. Ej: `ArrayList`, `HashSet`. Cada una tiene caracter칤sticas de rendimiento diferentes.
3. **Algoritmos:** M칠todos polim칩rficos reutilizables (ordenar, buscar, copiar) que funcionan sobre las interfaces.

### 2.1 La Jerarqu칤a Principal

La interfaz ra칤z es **`Collection`**, de la que descienden las principales familias (aunque `Map` no hereda de ella):

* **`List`** (Listas): Define una colecci칩n ordenada que permite elementos duplicados.
* **`Set`** (Conjuntos): Colecci칩n no ordenada (generalmente), **NO permiten duplicados**.
* **`HashSet`** (Mapas): Almacenan elementos individuales que asocia una *clave* con un *valor*. Las claves no pueden estar duplicadas.
* **`Queue`** (Colas): Estructuras FIFO (First In, First Out).
* **`Stack`** (Pilas): Estructuras LIFO (Last In, First Out).
* **`SortedSet`**: Conjuntos ordenados.

### 2.2. M칠todos de la Interfaz Collection

El JCF est치 dise침ado en base a **Interfaces**, que definen el comportamiento, y **Clases**, que implementan ese comportamiento.

La interfaz ra칤z es **`Collection`**, que define las operaciones b치sicas comunes a casi todas las estructuras de datos din치micas (excepto los Mapas, que tienen su propia jerarqu칤a).

Cualquier clase que implemente `Collection` (como `ArrayList` o `HashSet`) garantiza la disponibilidad de estos m칠todos:

| M칠todo | Descripci칩n T칠cnica |
| :--- | :--- |
| `int size()` | Retorna el n칰mero de elementos almacenados. |
| `boolean isEmpty()` | Retorna `true` si la colecci칩n no contiene elementos. |
| `boolean add(E e)` | Asegura que la colecci칩n contiene el elemento especificado. Retorna `true` si la colecci칩n cambi칩. |
| `boolean remove(Object o)` | Elimina una instancia del elemento especificado si est치 presente. |
| `boolean contains(Object o)`| Retorna `true` si la colecci칩n contiene el elemento especificado. |
| `void clear()` | Elimina todos los elementos de la colecci칩n. |

### 2.3. Algoritmos de la clase Collections (춰No confundir con `Collection`!)

Java proporciona una clase de utilidad llamada **`Collections`** (plural, con "s" al final) que contiene m칠todos est치ticos muy potentes para operar sobre las colecciones. Son como la "navaja suiza" del framework.

Estos son los tres m치s utilizados:

* **`Collections.sort(List lista)`**: Ordena una lista en orden ascendente (natural). Si es de n칰meros, de menor a mayor; si es de Strings, alfab칠ticamente.
* **`Collections.max(Collection col)`**: Busca y devuelve el elemento m치ximo de la colecci칩n.
* **`Collections.min(Collection col)`**: Busca y devuelve el elemento m칤nimo.

---

## 3. Fundamentos: Clases Wrapper y Tipos Gen칠ricos

Antes de abordar las colecciones, debemos comprender una restricci칩n fundamental de la arquitectura de Java:

!!! danger "Cuidado"
    Las Colecciones en Java solo pueden almacenar referencias a **OBJETOS, no tipos primitivos.**

Esto significa que no podemos crear un `ArrayList` directamente de tipos `int`, `double` o `boolean`. Para solucionar esto, Java utiliza las **Clases Wrapper** (Envoltorios).

### 3.1. Clases Wrapper (Envoltorios)

Cada tipo primitivo tiene una clase correspondiente que "envuelve" su valor en un objeto. Esto permite que los valores primitivos sean tratados como objetos y almacenados en colecciones.

| Tipo Primitivo | Clase Wrapper (Objeto) |
| :------------- | :--------------------- |
| `int`          | `Integer`              |
| `double`       | `Double`               |
| `char`         | `Character`            |
| `boolean`      | `Boolean`              |

### 3.2. Autoboxing y Unboxing

Java facilita la conversi칩n entre primitivos y Wrappers mediante dos mecanismos autom치ticos del compilador:

* **Autoboxing:** Conversi칩n autom치tica de un tipo primitivo a su objeto Wrapper correspondiente.
* **Unboxing:** Conversi칩n autom치tica de un objeto Wrapper a su tipo primitivo.

```java
import java.util.ArrayList;

public class EjemploWrapper {
    public static void main(String[] args) {
        // Declaraci칩n correcta usando el Wrapper Integer
        ArrayList<Integer> numeros = new ArrayList<>();

        // AUTOBOXING: El compilador convierte el primitivo 10 a new Integer(10)
        numeros.add(10); 

        // UNBOXING: El compilador extrae el int del objeto Integer autom치ticamente
        int valor = numeros.get(0); 
        
        System.out.println("Valor recuperado: " + valor);
    }
}
```

---

## 4. Listas: Secuencias Ordenadas

La interfaz **`List`** es, con diferencia, la estructura m치s utilizada en el d칤a a d칤a del desarrollo. Si vienes del mundo de los arrays, la Lista es su evoluci칩n natural y supervitaminada.

### 4.1. 쯈u칠 es una Lista?

Una Lista es una **colecci칩n ordenada** (una secuencia). Imag칤nala como una "Lista de la Compra" o una "Lista de Reproducci칩n" de Spotify:

1. **El Orden Importa:** Si a침ades "Pan", luego "Leche" y luego "Huevos", se guardan en ese orden exacto. El "Pan" es el primero (칤ndice 0), la "Leche" el segundo (칤ndice 1), etc.
2. **Admite Duplicados:** Puedes tener "Leche" dos veces en tu lista si necesitas comprar dos cartones. A la lista no le importa que el contenido sea igual, son dos elementos distintos en posiciones distintas.
3. **Acceso por Posici칩n:** Puedes decir "dame el tercer elemento" (`get(2)`) o "borra el primer elemento" (`remove(0)`).

### 4.2. 쯇ara qu칠 la usamos?

Usamos listas siempre que necesitemos agrupar elementos y nos importe el orden en que est치n, o necesitemos acceder a ellos por su posici칩n num칠rica.

* Una lista de alumnos en una clase.
* El historial de p치ginas visitadas en un navegador.
* Los mensajes de un chat (ordenados cronol칩gicamente).

### 4.3. Implementaciones: ArrayList vs LinkedList

Aunque hay varias, en el 99% de los casos usar치s una de estas dos:

* **`ArrayList`:** Internamente usa un **array**. Es rapid칤sima para leer (`get`), pero si insertas algo en medio, tiene que mover todos los elementos siguientes un paso a la derecha. **Es la opci칩n por defecto.**
* **`LinkedList`:** Internamente es una cadena de **nodos enlazados**. Es r치pida insertando en medio, pero lenta para leer porque tiene que recorrer la cadena nodo a nodo.

### 4.4. M칠todos Principales de `List`

A continuaci칩n, tienes las herramientas que usar치s constantemente. Supongamos una lista llamada `lista`.

| M칠todo | Descripci칩n | Ejemplo de C칩digo |
| :--- | :--- | :--- |
| **`add(E elemento)`** | A침ade el elemento al **final** de la lista. | `lista.add("Java");` |
| **`add(int index, E e)`** | Inserta el elemento en la **posici칩n indicada**, desplazando al resto. | `lista.add(0, "Python");` |
| **`get(int index)`** | Devuelve el elemento que est치 en esa posici칩n. | `String s = lista.get(1);` |
| **`set(int index, E e)`** | **Sustituye** el elemento de esa posici칩n por uno nuevo. | `lista.set(1, "C++");` |
| **`remove(int index)`** | Elimina el elemento de esa posici칩n y "cierra el hueco". | `lista.remove(0);` |
| **`remove(Object o)`** | Busca el primer elemento igual a ese y lo borra. | `lista.remove("Java");` |
| **`size()`** | Devuelve el n칰mero de elementos actuales. | `int n = lista.size();` |
| **`contains(Object o)`** | Devuelve `true` si la lista contiene ese elemento. | `boolean b = lista.contains("C++");` |
| **`indexOf(Object o)`** | Devuelve el 칤ndice de la primera aparici칩n (o -1 si no est치). | `int pos = lista.indexOf("C++");` |
| **`clear()`** | Vac칤a la lista por completo. | `lista.clear();` |

### 4.5. Visualizando una Lista

Este diagrama muestra c칩mo una lista (`ArrayList`) gestiona sus elementos y sus 칤ndices. Observa que los 칤ndices siempre son consecutivos (0, 1, 2...).

```mermaid
graph LR
    subgraph "Estructura de la Lista"
    direction LR
    N0[칈ndice 0: <br>'Ana'] --> N1[칈ndice 1: <br>'Beto']
    N1 --> N2[칈ndice 2: <br>'Carla']
    N2 --> N3[칈ndice 3: <br>'Dani']
    end
    style N0 fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    style N1 fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    style N2 fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    style N3 fill:#e1f5fe,stroke:#01579b,stroke-width:2px
```

### 4.6. Manejo b치sico de una lista

* **Instanciaci칩n de una Lista**: Para comenzar a trabajar con listas, lo primero que tenemos que saber es c칩mo instanciarlas (declararlas).
* **A침adir elementos a una lista**: Para a침adir elementos al final de una lista usaremos el m칠todo `add`. Ten en cuenta que el **wrapper** tiene que ser el mismo que usamos en la instanciaci칩n.

```java
import java.util.ArrayList;

public class EjemploLista {
    public static void main(String[] args) {
        
        // Instanciaci칩n de un ArrayList de Strings
        ArrayList<String> miLista = new ArrayList<>();

        // A침adimos elementos a la lisda de manera ordenada
        miLista.add("Ana");
        miLista.add("Beto");
        miLista.add("Carla");
        miLista.add("Dani");
    }
}
```

* **Iteraci칩n de una lista** (recorrer elementos): Usaremos un bucle `for` pero de una manera ligeramente distinta a la que hemos visto hasta ahora. `for( [tipo_dato] nombre_elemento : nombre_lista ) {}`.

```java
import java.util.ArrayList;

public class EjemploLista {
    public static void main(String[] args) {
        
        // Instanciaci칩n de un ArrayList de Strings
        ArrayList<String> miLista = new ArrayList<>();

        // A침adimos elementos a la lisda de manera ordenada
        miLista.add("Ana");
        miLista.add("Beto");
        miLista.add("Carla");
        miLista.add("Dani");

        // Iteraci칩n de una lista
        System.out.println("\n--- RECORRER ELEMENTOS DE UNA LISTA ---");
        for (String elemento : miLista) {
            System.out.println("- " + elemento);
        }
    }
}
```

Si lanzamos la ejecuci칩n del programa, la **salida est치ndar por pantalla** es la siguiente:

```bash
--- RECORRER ELEMENTOS DE UNA LISTA ---
- Ana
- Beto
- Carla
- Dani
```

### 4.7. Ejemplo Funcional: Gesti칩n de Inventario con ArrayList

A continuaci칩n, vamos a ver un ejemplo funcional con la mayor칤a de m칠todos de uso de una lista. Queremos un *Gestor de inventario* que realice las principales operaciones *CRUD (Create, Read, Update, Delete)*:

* **Crear**: A침adir un elemento a la lista.
* **Leer**: Accedemos a un elemento de una lista (seg칰n posici칩n).
* **Actualizar**: Modificamos el valor de un elemento en una posici칩n.
* **Eliminar**: Borramos un elemento. Podemos hacerlo por su *valor* o por su *posici칩n*.

Tambi칠n haremos uso de operaciones de utilidad:

* `isEmpty()`: Indica si la lista est치 vac칤a o no.
* `size()`: Devuelve el tama침o de la lista
* `contains([elemento])`: Indica si un elemento est치 o no en la lista.

!!! note "游댍 Comprobaci칩n"
    Comprueba el funcionamiento del programa. **Copia el c칩digo y ejec칰talo** en tu entorno para comprender c칩mo funciona.

```java
import java.util.ArrayList;
import java.util.Collections; // Utilidad para ordenar

public class GestorInventario {
    public static void main(String[] args) {
        // Instanciaci칩n de un ArrayList de Strings
        ArrayList<String> inventario = new ArrayList<>();

        // 1. Operaciones CRUD (Create, Read, Update, Delete)
        
        // CREATE: A침adir elementos
        inventario.add("Martillo");
        inventario.add("Destornillador");
        inventario.add("Taladro");
        inventario.add(0, "Sierra"); // Insertar al inicio (desplaza el resto)

        // READ: Acceso posicional
        System.out.println("Elemento en 칤ndice 2: " + inventario.get(2));

        // UPDATE: Modificar elementos
        inventario.set(1, "Martillo Neum치tico"); // Reemplaza "Martillo"

        // DELETE: Eliminar elementos
        inventario.remove("Taladro"); // Por objeto
        inventario.remove(0);         // Por 칤ndice ("Sierra")

        // 2. Operaciones de Utilidad
        System.out.println("쮼st치 vac칤o? " + inventario.isEmpty());
        System.out.println("Total de art칤culos: " + inventario.size());
        
        if (inventario.contains("Destornillador")) {
            System.out.println("El inventario contiene Destornillador.");
        }

        // Ordenaci칩n (usando la clase de utilidad Collections)
        Collections.sort(inventario);

        // 3. Iteraci칩n
        System.out.println("\n--- Inventario Actualizado ---");
        for (String articulo : inventario) {
            System.out.println("- " + articulo);
        }
    }
}
```

!!! example "Vamos a pornerlo en pr치ctica"
    Vamos a comenzar a crear un ejemplo. Crea un **programa** con una lista de *Videojuegos* que implemente y pruebe las operaciones **CRUD** que hemos visto.

### 4.8. Operaciones Especiales: Inserci칩n y Borrado Condicional

Antes de ver el ejemplo completo, es importante entender dos operaciones que distinguen a las listas de los arrays:

**A. Inserci칩n en medio de la lista**
A diferencia de los arrays, donde insertar un dato en medio requiere mover manualmente todos los elementos siguientes, las listas tienen un m칠todo m치gico: `add(int index, E element)`.

* **쯈u칠 hace?** Hace un hueco en la posici칩n `index`, inserta el nuevo dato y desplaza autom치ticamente todos los elementos posteriores una posici칩n a la derecha.
* **Ejemplo:** Si tienes `[A, C]` y haces `lista.add(1, "B")`, la lista pasa a ser `[A, B, C]`.

**B. Borrado Condicional (El peligro del bucle `for`)**
Borrar elementos de una lista mientras la recorres es una de las fuentes de errores m치s comunes en Java.

* **El Problema:** Si usas un bucle `for` o `for-each` y borras un elemento (`lista.remove(i)`), el tama침o de la lista cambia instant치neamente y los 칤ndices se mueven. Esto suele provocar que te saltes elementos o que el programa falle con una `ConcurrentModificationException`.
* **La Soluci칩n:** Para borrar de forma segura mientras recorres, debes usar un **Iterador** (`Iterator`). El iterador es un objeto que sabe "caminar" sobre la lista y tiene un m칠todo `remove()` seguro que mantiene la integridad de la estructura.

#### Ejemplo Funcional: Gestor de Notas

Vamos a ver un programa completo que gestiona las notas de una clase aplicando estos conceptos. F칤jate en c칩mo insertamos una nota olvidada en medio de la lista y c칩mo borramos los suspensos de forma segura.

```java
import java.util.ArrayList;
import java.util.Collections; // Utilidad para ordenar, m치ximo, m칤nimo...
import java.util.Iterator;    // Importante para el borrado seguro

public class GestionNotas {

    public static void main(String[] args) {
        // 1. Creaci칩n de la lista (vac칤a al principio)
        ArrayList<Double> notas = new ArrayList<>();
        double max = 0, min = 0;
        
        Double nota;

        // 2. A침adir datos al final (add)
        System.out.println("--- A침adiendo notas ---");
        notas.add(6.5);
        notas.add(4.2);
        notas.add(8.9);
        notas.add(5.0);
        notas.add(9.7);
        System.out.println("Notas iniciales: " + notas);

        // 3. INSERCI칍N EN MEDIO (add con 칤ndice)
        // Imaginemos que se nos olvid칩 una nota y debe ir en la segunda posici칩n (칤ndice 1)
        System.out.println("\n--- Insertando nota olvidada ---");
        notas.add(1, 7.5); 
        // Ahora el 4.2 (que estaba en 칤ndice 1) se ha movido al 2
        System.out.println("Notas tras inserci칩n: " + notas);

        // 4. Operaciones de lectura y c치lculo
        System.out.println("\n--- Estad칤sticas ---");
        System.out.println("Total de ex치menes: " + notas.size());
        
        max = Collections.max(notas);
        min = Collections.min(notas);
        
        System.out.println("Nota m치s alta: " + max);
        System.out.println("Nota m치s baja: " + min);

        // 5. BORRADO CONDICIONAL (Uso de Iterator)
        // Queremos borrar TODAS las notas suspensas (menores que 5)
        System.out.println("\n--- Eliminando suspensos ---");
        
        // Creamos el iterador
        Iterator<Double> it = notas.iterator();
        
        while(it.hasNext()) {         // Mientras queden elementos por visitar...
            nota = it.next();  // ...dame el siguiente
            
            if (nota < 5.0) {
                it.remove();          // 춰BORRADO SEGURO! El iterador gestiona el hueco
                System.out.println("Eliminada nota: " + nota);
            }
        }
        
        // 6. Resultado final
        System.out.println("\n--- Lista de Aprobados ---");
        System.out.println(notas);
    }
}
```

**Salida esperada del programa:**

```text
--- A침adiendo notas ---
Notas iniciales: [6.5, 4.2, 8.9, 5.0, 9.7]

--- Insertando nota olvidada ---
Notas tras inserci칩n: [6.5, 7.5, 4.2, 8.9, 5.0, 9.7]

--- Estad칤sticas ---
Total de ex치menes: 6
Nota m치s alta: 9.7
Nota m치s baja: 4.2

--- Eliminando suspensos ---
Eliminada nota: 4.2

--- Lista de Aprobados ---
[6.5, 7.5, 8.9, 5.0, 9.7]
```

---

## 5. Conjuntos (Set): Unicidad Garantizada

La interfaz **`Set`** modela la abstracci칩n matem치tica de un conjunto. Su caracter칤stica definitoria es que **NO permite elementos duplicados**.

* **Sin orden (generalmente):** No garantiza que los elementos se guarden en el orden en que se insertaron.
* **Sin acceso posicional:** No existe el m칠todo `get(i)`. No puedes pedir "el tercer elemento", porque no hay un orden secuencial fijo.

**쮺u치ndo usar un Set?**

칔salo cuando necesites garantizar unicidad: lista de correos para no enviar spam duplicado, DNI de usuarios, matr칤culas de coches en un parking, etc.

### 5.1. Implementaciones Principales

1. **`HashSet`**: Es la m치s r치pida y utilizada. No garantiza ning칰n orden. Usa una tabla hash interna.
2. **`TreeSet`**: Ordena los elementos autom치ticamente (por orden natural o comparador). Es m치s lento al insertar porque tiene que ordenar.
3. **`LinkedHashSet`**: Mantiene el orden de inserci칩n, pero es un poco m치s lento que `HashSet`.

### 5.2. Visualizando un Conjunto (Diagrama)

En este diagrama vemos c칩mo funciona un **Conjunto (`HashSet`)**:

1. Los elementos no tienen una posici칩n fija (칤ndice).
2. Si intentamos a침adir un duplicado (ej: 'Ana'), el conjunto lo rechaza y se mantiene igual.

```mermaid
graph LR
    subgraph "Conjunto"
    direction TB
    E1((Ana))
    E2((Beto))
    E3((Carla))
    end
    
    Nuevo((Ana)) -- "add('Ana')" --> E1
    
    style Nuevo fill:#ffcccc,stroke:#cc0000,stroke-width:2px,stroke-dasharray: 5 5
    style E1 fill:#ccffcc,stroke:#009900,stroke-width:2px
    
    linkStyle 0 stroke:#cc0000,stroke-width:2px,color:red;
```

> *Nota: La l칤nea discontinua roja indica que la inserci칩n del duplicado es rechazada.*

### 5.3. M칠todos Principales de `Set`

Supongamos un conjunto llamado `conjunto`.

| M칠todo | Descripci칩n | Ejemplo de C칩digo |
| :--- | :--- | :--- |
| **`add(E elemento)`** | A침ade el elemento si no existe. Devuelve `true` si lo a침adi칩, `false` si ya estaba. | `boolean exito = conjunto.add("Ana");` |
| **`remove(Object o)`** | Elimina el elemento si existe. Devuelve `true` si lo elimin칩. | `conjunto.remove("Beto");` |
| **`size()`** | Devuelve el n칰mero de elementos 칰nicos. | `int n = conjunto.size();` |
| **`contains(Object o)`** | Devuelve `true` si el conjunto contiene ese elemento. | `boolean b = conjunto.contains("Carla");` |
| **`isEmpty()`** | Devuelve `true` si el conjunto est치 vac칤o. | `boolean b = conjunto.isEmpty();` |
| **`clear()`** | Elimina todos los elementos. | `conjunto.clear();` |

### 5.4. Ejemplo Funcional: Invitados a una Fiesta

!!! note "游댍 Comprobaci칩n"
    Comprueba el funcionamiento del programa. **Copia el c칩digo y ejec칰talo** en tu entorno para comprender c칩mo funciona.

```java
import java.util.HashSet;
import java.util.Set;

public class FiestaPrivada {
    public static void main(String[] args) {
        // Usamos la interfaz Set para la referencia (Buenas pr치cticas)
        Set<String> invitados = new HashSet<>();
        boolean agregado;

        // 1. A침adir invitados
        invitados.add("Ana");
        invitados.add("Borja");
        invitados.add("Clara");

        // INTENTO DE DUPLICADO:
        // El m칠todo add devuelve 'false' si el elemento ya exist칤a.
        agregado = invitados.add("Ana");

        System.out.println("쯉e ha a침adido a Ana otra vez? ");
        if(!agregado) { // false
            System.out.println("No se ha podido agregar porque ya estaba");
        } else {
            System.out.println("Se ha podido agregar");
        }

        // 2. Comprobar existencia
        if (invitados.contains("Borja")) {
            System.out.println("Borja est치 en la lista.");
        }

        // 3. Eliminar
        invitados.remove("Clara");

        // 4. Recorrer (Solo con for-each o iterador, no hay 칤ndice)
        System.out.println("\n--- Lista Final (" + invitados.size() + ") ---");
        for (String nombre : invitados) {
            System.out.println("- " + nombre);
        }
    }
}
```

!!! example "Vamos a pornerlo en pr치ctica"
    Vamos a crear un programa que use conjuntos. El **programa** definir치 un conjunto de *Frutas* que implemente y pruebe las operaciones de conjuntos (`Set`) que hemos visto.

---

## 6. Mapas: Estructuras Asociativas (Clave-Valor)

La interfaz **`Map`** es una de las estructuras m치s potentes y utilizadas. A diferencia de las Listas y Conjuntos, un Mapa no guarda elementos sueltos, sino que establece una relaci칩n entre dos objetos: una **Clave** (Key) y un **Valor** (Value).

### 6.1. 쯈u칠 es un Mapa? (La analog칤a del Diccionario)

Imagina un **diccionario de ingl칠s**:

* Buscas una palabra (**Clave**) -> Encuentras su definici칩n (**Valor**).
* O una **agenda telef칩nica**: Buscas un nombre (**Clave**) -> Encuentras su n칰mero (**Valor**).
* O una **base de datos de empleados**: Buscas por DNI (**Clave**) -> Obtienes la ficha del empleado (**Valor**).

**Reglas de Oro de los Mapas:**

1. **Claves 칔nicas:** No puede haber dos claves iguales (no puede haber dos entradas para la palabra "House" en el diccionario). Si a침ades una clave que ya existe, **sobrescribes** el valor anterior.
2. **Valores Repetidos:** S칤 puede haber valores repetidos (varias personas pueden vivir en la misma ciudad).
3. **Acceso R치pido:** Los mapas est치n optimizados para encontrar el valor r치pidamente si conoces la clave.

### 6.2. Visualizando un Mapa (Diagrama)

En este diagrama vemos c칩mo las claves act칰an como un 칤ndice 칰nico para acceder a los valores.

```mermaid
graph LR
    subgraph "Claves (Keys)"
    K1[1111A]
    K2[2222B]
    K3[3333C]
    end

    subgraph "Valores (Values)"
    V1[Ana L칩pez]
    V2[Carlos Ruiz]
    V3[Beatriz Aranda]
    end

    K1 --> V1
    K2 --> V2
    K3 --> V3

    style K1 fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    style K2 fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    style K3 fill:#e1f5fe,stroke:#01579b,stroke-width:2px
```

### 6.3. Implementaci칩n Principal: HashMap

La interfaz **`Map`** no hereda de `Collection`, pero es parte fundamental del framework. Modela el concepto de "diccionario".

* **Estructura:** Almacena pares `(Key, Value)`.
* **Unicidad:** Las claves (**Keys**) son 칰nicas.
* **Acceso:** Los datos se recuperan por clave.

`HashMap` es la implementaci칩n est치ndar. No garantiza ning칰n orden espec칤fico de las claves.

### 6.4. M칠todos Principales de `Map`

Supongamos un mapa llamado `mapa` que asocia DNI (String) con Nombre (String).

| M칠todo | Descripci칩n | Ejemplo de C칩digo |
| :--- | :--- | :--- |
| **`put(K key, V value)`** | A침ade una pareja o **actualiza** el valor si la clave ya exist칤a. | `mapa.put("123A", "Pepe");` |
| **`get(Object key)`** | Devuelve el valor asociado a la clave, o `null` si no existe. | `String nombre = mapa.get("123A");` |
| **`remove(Object key)`** | Elimina la pareja asociada a esa clave. | `mapa.remove("123A");` |
| **`containsKey(Object key)`** | Devuelve `true` si la clave existe en el mapa. | `boolean existe = mapa.containsKey("123A");` |
| **`keySet()`** | Devuelve un `Set` con todas las **claves**. | `Set<String> claves = mapa.keySet();` |
| **`values()`** | Devuelve una `Collection` con todos los **valores**. | `Collection<String> nombres = mapa.values();` |
| **`entrySet()`** | Devuelve un `Set` de objetos `Map.Entry` (parejas clave-valor). Ideal para recorrer. | `Set<Map.Entry<String, String>> pares = mapa.entrySet();` |
| **`size()`** | Devuelve el n칰mero de parejas almacenadas. | `int n = mapa.size();` |
| **`clear()`** | Vac칤a el mapa. | `mapa.clear();` |

### 6.5. Ejemplo Funcional: Censo de Poblaci칩n

!!! note "游댍 Comprobaci칩n"
    Comprueba el funcionamiento del programa. **Copia el c칩digo y ejec칰talo** en tu entorno para comprender c칩mo funciona.

```java
import java.util.HashMap;
import java.util.Map;

public class CensoPoblacion {
    public static void main(String[] args) {
        HashMap<String, String> censo = new HashMap<>();

        // 1. Inserci칩n (put)
        censo.put("1111A", "Ana L칩pez");
        censo.put("2222B", "Carlos Ruiz");
        
        // Sobrescritura si la clave existe
        censo.put("1111A", "Ana L칩pez Garc칤a"); 

        // 2. Recuperaci칩n (get)
        System.out.println("Nombre: " + censo.get("2222B"));

        // 3. Recorrido eficiente
        for (Map.Entry<String, String> entrada : censo.entrySet()) {
            System.out.println("DNI: " + entrada.getKey() + " -> " + entrada.getValue());
        }
    }
}
```

!!! example "Vamos a pornerlo en pr치ctica"
    Vamos a crear un programa que maneje un diccionario, mapa o `HashMap` que almacene pares *clave-valor*. El **programa** definir치 un diccionario de *Coches* que asociar치 cada *matr칤cula* con su *modelo de coche*. Recuerda que los *valores* **pueden repetirse** pero las *claves* **no**.
