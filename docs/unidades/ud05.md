# Unidad 5. Programaci√≥n Orientada a Objetos (POO)

## 1. Introducci√≥n: Pensando en Objetos

La **Programaci√≥n Orientada a Objetos (POO)** no es solo una sintaxis nueva; es un **paradigma de programaci√≥n**. Un paradigma es un modelo o estilo fundamental de desarrollo de software.

Hasta ahora, has programado bajo el **paradigma estructurado** (o procedimental). En este enfoque, los datos (variables) y las acciones (funciones) est√°n separados. El programador es como un cocinero que sigue una receta paso a paso: "coge estos huevos, b√°telos, a√±ade sal". Si el programa crece, terminamos con miles de variables sueltas y funciones que las modifican sin control, generando un c√≥digo dif√≠cil de mantener ("c√≥digo espagueti").

La POO propone un cambio radical: **modelar el software bas√°ndonos en las cosas (objetos) que existen en el problema real**. En lugar de separar datos y l√≥gica, los empaquetamos juntos en unidades llamadas **Objetos**.

!!! info "Documentaci√≥n oficial"
    **Java** pertenece a la conocida empresa **Oracle**. Puedes consultar la [documentaci√≥n oficial de Oracle](https://docs.oracle.com/javase/tutorial/java/javaOO/index.html) para ampliar tu conocimiento sobre **Programaci√≥n Orientada a Objetos**.

### 1.1. Conceptos Fundamentales: La Tr√≠ada del Objeto

Para que algo sea considerado un objeto en este paradigma, debe cumplir con tres caracter√≠sticas esenciales que le dan sentido y autonom√≠a:

1. **Identidad:** Es la propiedad que permite distinguir un objeto de otro, incluso si sus contenidos son id√©nticos. En la vida real, dos monedas de un euro son iguales, pero son dos objetos distintos (tienen identidad propia). En Java, esta identidad la gestiona la referencia de memoria.
2. **Estado (Atributos):** Son los datos que caracterizan al objeto en un momento dado. Representan las propiedades o caracter√≠sticas (ej: color, tama√±o, velocidad actual).
3. **Comportamiento (M√©todos):** Son las acciones que el objeto puede realizar o las respuestas que puede dar ante mensajes de otros objetos (ej: frenar, cambiar de color, calcular total).

### 1.2. Clase vs. Objeto: La Abstracci√≥n

Es vital distinguir entre el concepto abstracto y la realidad concreta.

* **La Clase (El plano):** Es la definici√≥n abstracta, el plano o la plantilla. Define qu√© atributos y m√©todos tendr√°n los objetos, pero **no contiene datos concretos** ni ocupa memoria de ejecuci√≥n para almacenarlos.
* **El Objeto (La Instancia):** Es la concreci√≥n de la clase. Es un elemento tangible en la memoria del ordenador que se ha creado a partir de la clase.

```mermaid
classDiagram
    %% Definici√≥n de la Clase (El plano)
    class Coche {
        String color
        String marca
        int velocidad
        arrancar()
        frenar()
    }
    note for Coche "CLASE (Definici√≥n abstracta)"

    %% Objetos (Instancias concretas)
    class CocheDeJuan {
        color: "Rojo"
        marca: "Seat"
        velocidad: 0
    }
    class CocheDeMaria {
        color: "Azul"
        marca: "Ford"
        velocidad: 120
    }

    Coche <|-- CocheDeJuan : Instancia (new)
    Coche <|-- CocheDeMaria : Instancia (new)
```

### 1.3. Ejemplos de Abstracci√≥n en la Vida Real

El proceso de dise√±ar clases se llama **abstracci√≥n**: consiste en observar un objeto real, ignorar los detalles irrelevantes y quedarse solo con las caracter√≠sticas importantes para nuestro programa.

Veamos c√≥mo modelar√≠amos diferentes objetos cotidianos en clases de Java:

#### A. Una L√°mpara

Si queremos programar un sistema de dom√≥tica, no nos importa de qu√© material es la bombilla, solo si est√° encendida o no.

* **Estado (Atributos):** `estaEncendida` (boolean), `intensidad` (int).
* **Comportamiento (M√©todos):** `encender()`, `apagar()`, `regularIntensidad(int nivel)`.

#### B. Una Cuenta Bancaria

Para un banco, tu cuenta es un objeto digital.

* **Estado:** `numeroCuenta` (String), `saldo` (double), `titular` (String).
* **Comportamiento:** `ingresar(double cantidad)`, `retirar(double cantidad)`, `consultarSaldo()`.

#### C. Un Enemigo de Videojuego

Para un juego de rol.

* **Estado:** `puntosVida` (int), `fuerzaAtaque` (int), `tipoArma` (String).
* **Comportamiento:** `atacar(Personaje objetivo)`, `recibirDano(int cantidad)`, `gritar()`.

---

## 2. Clases y Objetos: El Plano y la Casa

Para entender la diferencia fundamental entre estos dos conceptos, usaremos una analog√≠a arquitect√≥nica:

* **La Clase es el Plano (Blueprints):**

    * El arquitecto dibuja un plano detallado. En √©l especifica d√≥nde van las ventanas, de qu√© material son las paredes y cu√°ntas habitaciones hay.
    * Pero **nadie puede vivir en un plano**. El plano es solo papel (o un archivo digital). No tiene paredes f√≠sicas, ni techo, ni ocupa un lugar en la calle. Es pura informaci√≥n.

* **El Objeto es la Casa Construida:**

    * Usando ese **mismo plano**, una constructora puede edificar 50 casas en una urbanizaci√≥n.
    * Cada casa es una **instancia** del plano.
    * Aunque todas se hicieron con el mismo plano, cada casa es independiente:
        * En la Casa N¬∫ 1 pueden pintar las paredes de azul.
        * En la Casa N¬∫ 2 pueden tener las luces encendidas.
        * Si se rompe una ventana en la Casa N¬∫ 3, no se rompe en la Casa N¬∫ 4.

En programaci√≥n:

* **La Clase** define la estructura.
* **El Objeto** ocupa memoria y tiene sus propios valores.

### 2.1. Definici√≥n de una Clase en Java

Una clase se define con la palabra reservada `class`. Por convenci√≥n, **los nombres de las clases siempre empiezan por May√∫scula**.

Vamos a crear nuestro hilo conductor: un **Personaje de Videojuego**.

!!! note "üîé Comprobaci√≥n"
    Comprueba el funcionamiento del programa. **Copia el c√≥digo y ejec√∫talo** en tu entorno para comprender c√≥mo funciona.

```java
// Definici√≥n de la Clase (El Molde)
public class Personaje {
    
    // ATRIBUTOS (Estado - Datos)
    String nombre;
    int vida;
    int nivel;

    // M√âTODOS (Comportamiento - Acciones)
    void saludar() {
        System.out.println("¬°Hola! Soy " + nombre + " y tengo nivel " + nivel);
    }
}
```

**Representaci√≥n Visual (Diagrama de Clases UML):**

As√≠ es como representamos esta clase en un diagrama profesional:

```mermaid
classDiagram
    class Personaje {
        - String nombre
        - int vida
        - int nivel
        + void saludar()
    }
```

### 2.2. Instanciaci√≥n: Creando Objetos

Para crear un objeto (una "casa") a partir de la clase, usamos el operador **`new`**.

```java
public class Main {
    public static void main(String[] args) {
        // Declaraci√≥n y creaci√≥n del Objeto 1
        Personaje heroe = new Personaje();
        
        // Accediendo a sus datos (¬°Ojo! A√∫n no tienen valor, est√°n vac√≠os)
        heroe.nombre = "Aragorn";
        heroe.vida = 100;
        heroe.nivel = 1;

        // Declaraci√≥n y creaci√≥n del Objeto 2
        Personaje villano = new Personaje();
        villano.nombre = "Orco Feo";
        villano.vida = 50;
        villano.nivel = 1;

        // Usando sus comportamientos
        heroe.saludar();   // Imprime: ¬°Hola! Soy Aragorn...
        villano.saludar(); // Imprime: ¬°Hola! Soy Orco Feo...
    }
}
```

**Diagrama de Instancias:**

Aqu√≠ podemos ver c√≥mo, a partir de una √∫nica clase `Personaje`, hemos creado dos objetos independientes en la memoria, cada uno con sus propios valores.

```mermaid
classDiagram
    %% Definici√≥n de la Clase (El plano)
    class Personaje {
        - String nombre
        - int vida
        - int nivel
        + void saludar()
    }

    class Heroe {
        - nombre: "Aragorn"
        - vida: 100
        - nivel: 1
    }
    class Villano {
        - nombre: "Orco Feo"
        - vida: 50
        - nivel: 1
    }

    Personaje <|-- Heroe : Instancia (new)
    Personaje <|-- Villano : Instancia (new)
```

!!! question "üíª Momento de Pr√°ctica: Tu primer Objeto"
    1. Crea una clase llamada `Coche` en un archivo `Coche.java`.
    2. A√±√°dele atributos: `marca` (String), `modelo` (String) y `velocidad` (int).
    3. Crea un m√©todo `void infoCoche()` que muestre un mensaje con la informaci√≥n del modelo y la marca.
    4. En el `main`, crea dos coches distintos (ej: un Ferrari y un Seat, con sus modelos) y muestra su informaci√≥n.

---

## 3. Miembros de una Clase

Una clase se compone de dos tipos de miembros: Atributos y M√©todos.

### 3.1. Atributos (Variables de Instancia)

Son las variables que guardan el estado de **cada objeto individualmente**. Cada objeto tiene su propia copia de estas variables.

* Si cambias la vida del `heroe`, la vida del `villano` NO cambia. Son independientes.

### 3.2. M√©todos

Son las funciones que definen qu√© puede hacer el objeto. Pueden leer y modificar los atributos del propio objeto.

Vamos a ampliar nuestro **Personaje** con una nueva habilidad: `recibirDano(int puntos)`.

```java
// As√≠ queda la clase Personaje ampliada
public class Personaje {
    String nombre;
    int vida;
    int nivel;

    void saludar() {
        System.out.println("¬°Hola! Soy " + nombre + " y tengo nivel " + nivel);
    }

    // NUEVO M√âTODO: L√≥gica de combate
    void recibirDano(int puntos) {
        // Modificamos el atributo 'vida' de ESTE objeto
        vida = vida - puntos;
        
        // Comprobamos el estado tras el cambio
        if (vida <= 0) {
            vida = 0; // No dejamos que sea negativa
            System.out.println("[MUERTE] " + nombre + " ha sido derrotado.");
        } else {
            System.out.println("[DA√ëO] " + nombre + " ha recibido " + puntos + " de da√±o. Vida restante: " + vida);
        }
    }
}
```

!!! question "üíª Momento de Pr√°ctica: ¬°A la batalla!"
    Ahora te toca a ti probar este nuevo m√©todo. Vuelve a tu clase principal (`JuegoMain`) y modifica el c√≥digo para simular una pelea:

    1. Copia el c√≥digo nuevo del m√©todo `recibirDano` dentro de tu clase `Personaje`.
    2. En el `main`, haz que el `villano` reciba 30 puntos de da√±o.
    3. Luego, haz que reciba otros 50 puntos.
    4. ¬øQu√© pasa si recibe un golpe fatal de 100 puntos? Comprueba que sale el mensaje de derrota.

### 3.3. El Puntero `this`: ¬øQui√©n soy yo?

En Java, cuando escribes c√≥digo dentro de una clase, a veces necesitas referirte al propio objeto que est√° ejecutando el c√≥digo, es decir, "MI atributo" o "MI m√©todo". Para eso usamos la palabra clave **`this`**.

* **`this`** es una referencia al **objeto actual** que est√° ejecutando el c√≥digo.

Es muy √∫til para evitar ambig√ºedades cuando un par√°metro se llama igual que un atributo. Esto se llama **Shadowing** (Sombreado).

```java
// Forma INCORRECTA (Ambig√ºedad)
void cambiarNombre(String nombre) {
    nombre = nombre; // ¬øCu√°l es cu√°l? Java asigna el par√°metro a s√≠ mismo. ¬°No hace nada!
}

// Forma CORRECTA (Usando this)
void cambiarNombre(String nombre) {
    this.nombre = nombre; // "Mi atributo nombre" = "El par√°metro nombre"
}
```

#### Aplic√°ndolo a nuestro Personaje

Vamos a a√±adir un m√©todo para cambiar el nombre del personaje, usando `this` para diferenciar el atributo del par√°metro.

```java
public class Personaje {
    String nombre;
    int vida;
    int nivel;

    // ... otros m√©todos ...

    // M√©todo para renombrar al personaje
    void cambiarNombre(String nombre) {
        // Usamos 'this' para dejar claro que queremos modificar el atributo de la clase
        this.nombre = nombre; 
    }
}
```

!!! question "üíª Momento de Pr√°ctica: Ampliando el Coche"
    Vamos a mejorar tu clase `Coche`.

    1. A√±ade un m√©todo `void frenar(int cantidad)` que reduzca la velocidad en la *cantidad* correspondiente.
    2. A√±ade un m√©todo `void acelerar(int cantidad)` que acelere la velocidad en la *cantidad* dada.
    3. **L√≥gica:** El coche no puede tener velocidad negativa. Si al frenar baja de 0, la velocidad debe quedarse en 0 y mostrar un mensaje "¬°Coche detenido!".
    4. **L√≥gica:** El coche no puede sobrepasar la velocidad m√°xima (por ejemplo 200). Si al acelerar pasa de 200, la velocidad debe quedarse en 200 y mostrar un mensaje "¬°Velocidad m√°xima alcanzada!".
    5. Prueba a acelerar y frenar en el `main`.

---

## 4. Encapsulamiento y Visibilidad (La Caja Negra)

El **Encapsulamiento** es el principio fundamental de la POO que nos dice: **"Oculta los detalles internos y muestra solo lo que sea seguro usar"**.

### 4.1 ¬øPor qu√© necesitamos proteger nuestros datos?

Imagina que est√°s conduciendo tu coche. Tienes acceso al volante, los pedales y la palanca de cambios (Interfaz P√∫blica). Pero el fabricante del coche ha protegido el motor bajo un cap√≥ cerrado.

¬øQu√© pasar√≠a si pudieras tocar los pistones del motor directamente mientras conduces?

1. **Integridad:** Podr√≠as romper el motor sin querer.
2. **Seguridad:** Podr√≠as hacerte da√±o.
3. **Complejidad:** Tendr√≠as que saber mec√°nica avanzada solo para ir a comprar pan.

En programaci√≥n ocurre lo mismo. Si dejas que cualquiera modifique la `vida` de tu personaje directamente (`heroe.vida = -5000`), tu programa podr√≠a romperse o comportarse de forma absurda (¬°personajes zombies con vida negativa!).

En Java, usamos los **Modificadores de Acceso** para controlar esto:

* **`public`:** Acceso total. Es la "puerta abierta" de la clase.
* **`private`:** Acceso restringido. Solo la propia clase puede ver y tocar estos miembros.

**Regla de Oro:** Por defecto, los **atributos** deben ser siempre **`private`**.

### 4.2 Getters y Setters

Si hacemos los atributos privados, ¬øc√≥mo trabajamos con ellos? Usando m√©todos p√∫blicos controlados, conocidos como **Accessors**.

#### 1. El Setter (M√©todo de Modificaci√≥n)

Se usa para **asignar** un valor a un atributo privado.

* **Ventaja:** Nos permite validar el dato antes de guardarlo. Si el dato es incorrecto, podemos rechazarlo o corregirlo.
* *Analog√≠a:* Es como el guardia de seguridad de una discoteca. No deja entrar a cualquiera.

#### 2. El Getter (M√©todo de Lectura)

Se usa para **recuperar** el valor de un atributo privado.

* **Ventaja:** Nos permite controlar c√≥mo se muestra el dato o incluso devolver un dato calculado.
* *Analog√≠a:* Es como mirar a trav√©s de un cristal blindado. Puedes ver lo que hay, pero no tocarlo.

### 4.3. M√©todos Ocultos (Privados)

A veces, una clase necesita realizar tareas internas complejas que no deben ser vistas ni usadas desde fuera. A estos m√©todos se les llama **Helpers** o m√©todos auxiliares, y se declaran como **`private`**.

Imagina un m√©todo que calcula si un golpe recibido es cr√≠tico. Solo la clase `Personaje` debe usarlo cuando recibe da√±o; nadie desde fuera deber√≠a poder llamar a `esGolpeCritico()` directamente.

```java
private boolean esGolpeCritico() {
    // L√≥gica interna compleja (ej: n√∫meros aleatorios)
    return Math.random() > 0.95; // 5% de probabilidad
}
```

Si el `Personaje` recibe un *golpe cr√≠tico* (tiene un 5% de posibilidades de recibirlo), al da√±o recibido se le a√±ade 10 puntos. Nuestro m√©todo `recibirDano` puede llamar **internamente** al nuevo m√©todo:

```java
    public void recibirDano(int puntos) {
        
        this.vida -= puntos;

        if(esGolpeCritico()) {
            this.vida = this.vida - 10;
            System.out.println("[GOLPE CR√çTICO] Recibe 10 ptos. extra de da√±o");
        }

        if (this.vida <= 0) {
            this.vida = 0;
            System.out.println("[GAME OVER] " + this.nombre + " ha muerto.");
        } else {
            System.out.println("[DA√ëO] " + this.nombre + " tiene " + this.vida + " ptos. de vida");
        }
    }
```

### 4.4. C√≥digo Final de la Clase Personaje

Aqu√≠ tienes la versi√≥n profesional de nuestra clase `Personaje`, aplicando encapsulamiento, constructores y m√©todos.

!!! note "üîé Comprobaci√≥n"
    Comprueba el funcionamiento del programa. **Copia el c√≥digo y ejec√∫talo** en tu entorno para comprender c√≥mo funciona.

```java
public class Personaje {
    
    // 1. ATRIBUTOS (Privados para protegerlos)
    private String nombre;
    private int vida;
    private int nivel;

    // 2. M√âTODOS DE COMPORTAMIENTO
    public void saludar() {
        System.out.println("¬°Hola! Soy " + this.nombre + " (Nv. " + this.nivel + ")");
    }

    public void recibirDano(int puntos) {
        
        this.vida -= puntos;

        if(esGolpeCritico()) {
            this.vida = this.vida - 10;
            System.out.println("[GOLPE CR√çTICO] Recibe 10 ptos. extra de da√±o");
        }

        if (this.vida <= 0) {
            this.vida = 0;
            System.out.println("[GAME OVER] " + this.nombre + " ha muerto.");
        } else {
            System.out.println("[DA√ëO] " + this.nombre + " tiene " + this.vida + " ptos. de vida");
        }
    }

    // 3. HELPERS. M√©todos privados

    private boolean esGolpeCritico() {
        // L√≥gica interna compleja (ej: n√∫meros aleatorios)
        return Math.random() > 0.95; // 5% de probabilidad
    }

    // 4. GETTERS Y SETTERS (La Interfaz P√∫blica)

    // Getter para el nombre
    public String getNombre() {
        return this.nombre;
    }

    // Setter para el nombre (podr√≠amos validar que no sea vac√≠o)
    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    // Getter para la vida
    public int getVida() {
        return this.vida;
    }

    // Setter INTELIGENTE para la vida
    public void setVida(int vida) {
        if (vida < 0) {
            System.out.println("Error: No se puede asignar vida negativa a " + this.nombre);
            this.vida = 0; // Correcci√≥n autom√°tica
        } else {
            this.vida = vida;
        }
    }

    // Getter para el nivel
    public int getNivel() {
        return this.nivel;
    }

    // Setter para el nivel
    public void setNivel(int nivel) {
        this.nivel = nivel;
    }
}
```

### 4.5. Diagrama de Clases UML (Encapsulado)

Observa c√≥mo cambian los s√≠mbolos:

* `-` significa **private** (candado cerrado).
* `+` significa **public** (puerta abierta).

```mermaid
classDiagram
    class Personaje {
        - String nombre
        - int vida
        - int nivel
        + void saludar()
        + void recibirDano(int)
        + String getNombre()
        + void setNombre(String)
        + int getVida()
        + void setVida(int)
        + int getNivel()
        + void setNivel(int)
        + boolean esGolpeCritico()$
    }
```

### 4.6. Ejemplo de Uso en el Main

Veamos c√≥mo usamos esta clase segura. F√≠jate que ya no podemos hacer `p.vida = -100`, el compilador no nos dejar√°.

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("--- INICIO DEL JUEGO ---");

        // 1. Instanciaci√≥n
        Personaje heroe = new Personaje();

        heroe.setNombre("Aragorn");
        heroe.setVida(100);
        heroe.setNivel(1);

        Personaje villano = new Personaje();

        villano.setNombre("Orco feo");
        villano.setVida(50);
        villano.setNivel(1);

        // 2. Uso de Getters para leer informaci√≥n
        System.out.println("El h√©roe se llama: " + heroe.getNombre());
        System.out.println("Vida actual: " + heroe.getVida());

        // 3. Intento de sabotaje (Asignar vida negativa)
        // heroe.vida = -500; // ¬°ERROR DE COMPILACI√ìN! No es visible.
        
        System.out.println("\n--- INTENTO DE TRAMPA ---");
        heroe.setVida(-999); // Usamos el setter
        System.out.println("Vida tras el intento: " + heroe.getVida()); // Sigue siendo 0, no -999

        // 4. Combate legal
        System.out.println("\n--- COMBATE ---");
        villano.recibirDano(60); // El m√©todo gestiona la l√≥gica interna
    }
}
```

!!! question "üíª Momento de Pr√°ctica: Protegiendo tu Coche"
    Vuelve a tu clase `Coche`.

    1. Cambia la visibilidad de todos los atributos de la clase a `private`.
    2. Intenta acceder directamente desde el main (`miCoche.velocidad = 200`). Ver√°s que da error.
    3. Crea un m√©todo `setVelocidad(int v)` que impida poner una velocidad negativa.
    4. Usa el setter en el main para probarlo.

---

## 5. Constructores: Naciendo con Estado

Hasta este momento, hemos creado nuestros objetos en dos pasos:

1. Los cre√°bamos vac√≠os con `new Personaje()`.
2. Les d√°bamos valores l√≠nea a l√≠nea usando los *setters*.

**¬øEl problema?** Es un proceso propenso a errores humanos. ¬øQu√© pasa si creas un `Personaje` pero se te olvida ponerle nombre o vida? Tendr√≠as un objeto "zombie" o incompleto circulando por tu programa, lo cual podr√≠a causar errores graves m√°s adelante.

El **Constructor** es un m√©todo especial dise√±ado para solucionar esto. Se ejecuta **autom√°ticamente** en el momento exacto de la creaci√≥n del objeto (al usar `new`). Su misi√≥n es garantizar que el objeto nazca en un estado v√°lido.

### 5.1. Caracter√≠sticas T√©cnicas

Para que un m√©todo sea un constructor, debe cumplir dos reglas estrictas:

1. Tener **exactamente el mismo nombre** que la clase.
2. **No tener tipo de retorno** (ni siquiera `void`). No devuelve nada, devuelve el objeto mismo.

### 5.2. Tipos de Constructores

#### A. El Constructor por Defecto (El Invisible)

Si t√∫ no escribes *ning√∫n* constructor en tu clase, Java te regala uno invisible y vac√≠o: `public Personaje() {}`. Este es el que nos permit√≠a hacer `new Personaje()` hasta ahora.

!!! warning "Importante"
    En el momento en que escribas T√ö un constructor (con par√°metros), Java retira el constructor por defecto. Si quieres seguir us√°ndolo, tendr√°s que escribirlo expl√≠citamente.

#### B. Constructores con Par√°metros

Son los m√°s √∫tiles. Nos obligan a pasar los datos necesarios para que el objeto exista.

```java
public class Personaje {
    private String nombre;
    private int vida;
    private int nivel;

    // Constructor: Obliga a dar un nombre, una vida y un nivel al nacer
    public Personaje(String nombre, int vida, int nivel) {
        this.nombre = nombre;
        this.setVida(vida); // ¬°Buena pr√°ctica! Usar el setter para validar incluso al nacer
        this.nivel = nivel;
    }
}
```

Ahora, es **imposible** crear un personaje vac√≠o. El compilador nos obligar√° a hacer: `new Personaje("Gandalf", 150, 5)`.

#### C. El Constructor de Copia

A veces necesitamos crear un objeto que sea una **copia exacta** de otro objeto que ya existe (un clon). Para eso usamos un constructor que recibe como par√°metro un objeto de su misma clase.

```java
    // Constructor de Copia
    public Personaje(Personaje p) {
        this.nombre = p.nombre;
        this.vida = p.vida;
        this.nivel = p.nivel;
    }
```

### 5.3. Sobrecarga de Constructores (Overloading)

A veces queremos flexibilidad. Quiz√°s queremos crear un personaje dando todos los datos, o quiz√°s solo dando el nombre y asumiendo valores por defecto para el resto.

Podemos tener m√∫ltiples constructores siempre que sus **par√°metros sean diferentes** (en cantidad o tipo).


### 5.4. Resultado Final: La Clase Personaje Profesional

Aqu√≠ tienes c√≥mo queda nuestra clase integrando **Encapsulamiento** (atributos privados y getters/setters) y **Constructores**.

!!! note "üîé Comprobaci√≥n"
    Comprueba el funcionamiento del programa. **Copia el c√≥digo y ejec√∫talo** en tu entorno para comprender c√≥mo funciona.

```java
public class Personaje {
    
    // 1. ESTADO (Privado)
    private String nombre;
    private int vida;
    private int nivel;

    // 2. CONSTRUCTORES (Sobrecarga)

    // Opci√≥n A: Constructor completo (Control total)
    public Personaje(String nombre, int vida, int nivel) {
        this.nombre = nombre;
        this.setVida(vida); // Usamos setter para validar
        this.setNivel(nivel);
    }

    // Opci√≥n B: Constructor r√°pido (Valores por defecto)
    // Solo pide el nombre. Asume vida=100 y nivel=1.
    public Personaje(String nombre) {
        this.nombre = nombre;
        this.vida = 100;
        this.nivel = 1;
    }

    // Opci√≥n C: Constructor copia
    // Recibe otro personaje y copia sus atributos
    public Personaje(Personaje p) {
        this.nombre = p.nombre;
        this.vida = p.vida;
        this.nivel = p.nivel;
    }

    // 3. M√âTODOS (Comportamiento)
    public void saludar() {
        System.out.println("¬°Hola! Soy " + this.nombre + " (Nv. " + this.nivel + ")");
    }

    public void recibirDano(int puntos) {
        
        this.vida -= puntos;

        if(esGolpeCritico()) {
            this.vida = this.vida - 10;
            System.out.println("[GOLPE CR√çTICO] Recibe 10 ptos. extra de da√±o");
        }

        if (this.vida <= 0) {
            this.vida = 0;
            System.out.println("[GAME OVER] " + this.nombre + " ha muerto.");
        } else {
            System.out.println("[DA√ëO] " + this.nombre + " tiene " + this.vida + " ptos. de vida");
        }
    }

    // 4. HELPERS. M√©todos privados

    private boolean esGolpeCritico() {
        // L√≥gica interna compleja (ej: n√∫meros aleatorios)
        return Math.random() > 0.95; // 5% de probabilidad
    }

    // 5. GETTERS Y SETTERS
    public String getNombre() { return nombre; }
    public void setNombre(String nombre) { this.nombre = nombre; }

    public int getVida() { return vida; }
    public void setVida(int vida) {
        if (vida < 0) {
            System.out.println("Error: Vida negativa no permitida.");
            this.vida = 0;
        } else {
            this.vida = vida;
        }
    }

    public int getNivel() { return nivel; }
    public void setNivel(int nivel) { 
        if (nivel < 1) nivel = 1; // M√≠nimo nivel 1
        else this.nivel = nivel; 
    }
}
```

### 5.5. Uso en el Programa Principal

F√≠jate c√≥mo la creaci√≥n de objetos ahora es mucho m√°s robusta y limpia.

```java
public class Main {
    public static void main(String[] args) {
        
        // Usando el Constructor Completo
        Personaje heroe = new Personaje("Aragorn", 150, 10);
        
        // Usando el Constructor R√°pido
        Personaje villano = new Personaje("Goblin"); // Vida 100, Nivel 1 autom√°ticos

        heroe.saludar();
        villano.saludar();

        // Intento de crear un personaje vac√≠o... ¬°ERROR DE COMPILACI√ìN!
        // Personaje fantasma = new Personaje(); // Java te dice: "¬øD√≥nde est√°n los datos?"

        // Personaje copia "clonamos" el villano

        Personaje villano2 = new Personaje(villano); // villano2 es una copia id√©ntica de villano
    }
}
```

!!! question "üíª Momento de Pr√°ctica: La F√°brica de Coches"
    Vamos a profesionalizar tu clase `Coche`.

    1.  Elimina cualquier inicializaci√≥n manual que tuvieras en el `main`.
    2.  Crea un **Constructor Completo** que pida `marca`, `modelo` y `velocidad` (los datos los pedir√° al usuario antes de llamar al constructor).
    3.  Crea un **Constructor Parcial** que solo pida `marca` y `modelo` (la velocidad debe iniciarse a 0).
    4.  Crea un **Constructor Copia**.
    5.  En el `main`, intenta crear un coche con `new Coche()`. ¬øQu√© ocurre?
    6.  Crea dos coches usando los dos constructores nuevos que has programado y muestra sus datos.
    7.  Copia en un tercer coche, el coche segundo.

---

## 6. Miembros Est√°ticos (`static`)

Hasta ahora, cada objeto ten√≠a su propia copia de los atributos (cada `Personaje` ten√≠a su propio `nombre`). Pero, ¬øy si queremos un dato que sea **compartido** por todos?

Imagina un contador de **"Total de Personajes Creados"**.

* Si se lo damos a "Aragorn", solo √©l sabr√≠a el dato.
* Si se lo damos a "Legolas", tendr√≠amos el dato duplicado.
* Ese dato no pertenece a un personaje concreto, pertenece al **JUEGO** (a la Clase).

Para eso usamos la palabra clave **`static`**.

* **Atributo Est√°tico:** Existe una √∫nica copia en memoria para toda la aplicaci√≥n. Si un objeto lo modifica, cambia para todos.
* **M√©todo Est√°tico:** Se puede llamar sin crear ning√∫n objeto (como `Math.sqrt()`). No puede usar `this` porque no est√° ligado a ninguna instancia concreta.

```java
public class Personaje {
    // Variable de instancia (cada uno tiene la suya)
    private String nombre; 
    
    // Variable de clase (COMPARTIDA por todos)
    public static int contadorPersonajes = 0; 

    public Personaje(String nombre) {
        this.nombre = nombre;
        // Cada vez que nace uno, aumentamos el contador global
        Personaje.contadorPersonajes++; 
    }
}
```

Uso:

```java
Personaje p1 = new Personaje("A");
Personaje p2 = new Personaje("B");

// Accedemos a trav√©s de la CLASE, no del objeto
System.out.println("Total creados: " + Personaje.contadorPersonajes); // Imprime 2
```

### 6.1. C√≥digo Final de la Clase Personaje

Aqu√≠ tienes la clase definitiva, integrando **Encapsulamiento**, **Constructores**, **L√≥gica** y **Miembros Est√°ticos**.

!!! note "üîé Comprobaci√≥n"
    Comprueba el funcionamiento del programa. **Copia el c√≥digo y ejec√∫talo** en tu entorno para comprender c√≥mo funciona.

```java
public class Personaje {
    
    // --- 1. ATRIBUTOS EST√ÅTICOS (De la Clase) ---
    // Contador compartido por TODOS los objetos Personaje
    private static int contadorPersonajes = 0;

    // --- 2. ATRIBUTOS DE INSTANCIA (Del Objeto) ---
    private String nombre;
    private int vida;
    private int nivel;

    // --- 3. CONSTRUCTORES ---
    public Personaje(String nombre, int vida, int nivel) {
        this.nombre = nombre;
        this.setVida(vida); // Usamos setter para validar
        this.nivel = nivel;
        
        // ¬°IMPORTANTE! Cada vez que nace un personaje, aumentamos el contador global
        Personaje.contadorPersonajes++;
    }

    // Constructor r√°pido
    public Personaje(String nombre) {
        this(nombre, 100, 1); // Llamada al otro constructor
    }

    // Constructor copia
    public Personaje(Personaje p) {
        this.nombre = p.nombre;
        this.vida = p.vida;
        this.nivel = p.nivel;
    }

    // --- 4. M√âTODOS DE COMPORTAMIENTO ---
    public void saludar() {
        System.out.println("¬°Hola! Soy " + this.nombre + " (Nv. " + this.nivel + ")");
    }

     public void recibirDano(int puntos) {
        
        this.vida -= puntos;

        if(esGolpeCritico()) {
            this.vida = this.vida - 10;
            System.out.println("[GOLPE CR√çTICO] Recibe 10 ptos. extra de da√±o");
        }

        if (this.vida <= 0) {
            this.vida = 0;
            System.out.println("[GAME OVER] " + this.nombre + " ha muerto.");
        } else {
            System.out.println("[DA√ëO] " + this.nombre + " tiene " + this.vida + " ptos. de vida");
        }
    }

    private boolean esGolpeCritico() {
        return Math.random() > 0.95;
    }

    // --- 5. M√âTODOS EST√ÅTICOS ---
    // Permite consultar el contador sin tener ning√∫n personaje creado
    public static int getTotalPersonajes() {
        return Personaje.contadorPersonajes;
    }

    // --- 6. GETTERS Y SETTERS ---
    public String getNombre() { return nombre; }
    public void setNombre(String nombre) { this.nombre = nombre; }

    public int getVida() { return vida; }
    public void setVida(int vida) {
        if (vida < 0) {
            System.out.println("Error: Vida negativa no permitida.");
            this.vida = 0;
        } else {
            this.vida = vida;
        }
    }
    
    public int getNivel() { return nivel; }
}
```

Los miembros est√°ticos suelen representarse subrayados. En este diagrama, el contador es est√°tico.

```mermaid
classDiagram
    class Personaje {
        - String nombre
        - int vida
        - int nivel
        - static int contadorPersonajes$
        + Personaje(String, int, int)
        + Personaje(String)
        + Personaje(Personaje)
        + void saludar()
        + void recibirDano(int)
        + String getNombre()
        + void setNombre(String)
        + int getVida()
        + void setVida(int)
        + int getNivel()
        + void setNivel(int)
        + boolean esGolpeCritico()$
        + static int getTotalPersonajes()$
    }
```

### 6.2. Ejemplo de Uso en el Main

Observa c√≥mo accedemos a la informaci√≥n est√°tica usando el **Nombre de la Clase** (`Personaje.algo`), no el nombre de un objeto.

```java
public class JuegoMain {
    public static void main(String[] args) {
        
        System.out.println("--- INICIO DEL JUEGO ---");
        
        // 1. Consultar est√°tico antes de crear nada
        System.out.println("Personajes actuales: " + Personaje.getTotalPersonajes()); // Salida: 0

        // 2. Crear objetos (El constructor aumentar√° el contador solo)
        Personaje p1 = new Personaje("Aragorn", 150, 10);
        Personaje p2 = new Personaje("Legolas", 120, 10);
        Personaje p3 = new Personaje("Gimli");

        // 3. Consultar est√°tico de nuevo
        System.out.println("Personajes actuales: " + Personaje.getTotalPersonajes()); // Salida: 3

        // 4. Probar encapsulamiento y m√©todos
        p1.recibirDano(50);
        p1.setVida(-200); // El setter lo corregir√° a 0
        
        System.out.println("Vida de Aragorn: " + p1.getVida());
    }
}
```

!!! question "üíª Momento de Pr√°ctica: La F√°brica de Coches (Final)"
    Para terminar tu clase `Coche`, vamos a a√±adirle control de producci√≥n.

    1.  A√±ade un atributo privado y est√°tico `contadorCoches`.
    2.  Modifica tus constructores para que aumenten este contador cada vez que se cree un coche nuevo.
    3.  Crea un m√©todo p√∫blico y est√°tico `getCochesFabricados()` que devuelva ese n√∫mero.
    4.  A√±ade tambi√©n una **Constante Est√°tica** (public static final) llamada `RUEDAS = 4` (todos los coches tienen 4 ruedas).
    5.  En el `main`:
        * Imprime cu√°ntas ruedas tiene un coche usando la constante.
        * Crea 3 coches.
        * Imprime el total de coches fabricados llamando al m√©todo est√°tico.