# Unidad 6. Programaci√≥n Orientada a Objetos Avanzada

## 1. Clases Compuestas (Composici√≥n)

Hasta ahora, hemos trabajado con objetos sencillos (como un `Coche` con velocidad o color). Sin embargo, en el mundo profesional, el software se parece m√°s a un juego de **LEGO**.

**¬øC√≥mo construyes un castillo de Lego?** No fabricas el pl√°stico desde cero. Tomas bloques que ya existen (ventanas, puertas, ladrillos) y los "compones" para crear algo nuevo y m√°s complejo.

La **Composici√≥n** es exactamente eso: crear clases complejas usando otras clases como "piezas".

### 1.1. La Relaci√≥n "TIENE-UN" (Has-A)

Para saber si est√°s ante un caso de composici√≥n, usa la prueba del "TIENE-UN":

*   Un `Ordenador` **TIENE UN** `Procesador`.
*   Un `Personaje` **TIENE UN** `Arma`.
*   Una `Casa` **TIENE UNA** `Cocina`.

(Si la frase fuera "ES UN", estar√≠amos hablando de Herencia, que veremos luego).

!!! tip "Consejo Pro"
    En Java, implementamos esto declarando atributos que son **referencias a otros Objetos**, en lugar de simples `int` o `String`.

### 1.2. Ventajas: Delegaci√≥n

La clase contenedora (`Personaje`) no necesita saber c√≥mo dispara el `Arma`. Solo le pide que dispare.
A esto se le llama **Delegaci√≥n**: "Yo (Personaje) no calculo el da√±o, *delego* esa tarea a mi arma".

### 1.3. Ejemplo: Personaje y Arma

Vamos a ver c√≥mo se traduce esto a c√≥digo real.

```java
// PIEZA 1: El objeto "peque√±o"
public class Arma {
    private String nombre;
    private int dano;

    public Arma(String nombre, int dano) {
        this.nombre = nombre;
        this.dano = dano;
    }

    public int getDano() { return dano; }
    public String getNombre() { return nombre; }
}
```

```java
// PIEZA 2: El objeto "contenedor"
public class Personaje {
    private String nombre;
    private int vida;

    // COMPOSICI√ìN: El personaje TIENE un Arma
    // En memoria, esto es una referencia (un hueco) para conectar un objeto Arma.
    private Arma armaEquipada;

    public Personaje(String nombre, Arma armaInicial) {
        this.nombre = nombre;
        // Importante: Validamos que no nos pasen un arma 'null'
        setArmaEquipada(armaInicial);
    }

    public void atacar() {
        // DELEGACI√ìN: Usamos el objeto interno para trabajar
        System.out.println(this.nombre + " ataca con " + this.armaEquipada.getNombre());
        System.out.println("Da√±o causado: " + this.armaEquipada.getDano());
    }

    public void cambiarArma(Arma nuevaArma) {
        setArmaEquipada(nuevaArma);
        System.out.println(this.nombre + " ahora lleva: " + nuevaArma.getNombre());
    }

    public Arma getArmaEquipada() {
        return armaEquipada;
    }

    public void setArmaEquipada(Arma nuevoArma) {
        if (nuevoArma != null) {
            this.armaEquipada = nuevoArma;
        } else {
            System.out.println("¬°Cuidado! Se intenta crear sin arma.");
            Arma punyoPorDefecto = new Arma("Pu√±o", 1);
            this.armaEquipada = punyoPorDefecto;
        }
    }
    
}
```

### 1.4. Composici√≥n con Colecciones (Relaci√≥n "TIENE-MUCHOS")

¬øY si nuestro personaje tiene una mochila? Una mochila no tiene un solo objeto, tiene **muchos**.
Aqu√≠ es donde combinamos Composici√≥n con `ArrayList`.

```java
import java.util.ArrayList;

// CLASE COMPONENTE
public class Item {
    private String nombre;
    private int durabilidad; // Ejemplo: 100 (nuevo) a 0 (roto)

    public Item(String nombre, int durabilidad) {
        this.nombre = nombre;
        this.durabilidad = durabilidad;
    }
    
    @Override
    public String toString() { return nombre + " [" + durabilidad + "%]"; }
}
```

```java
// CLASE COMPUESTA INTERMEDIA
public class Mochila {
    private ArrayList<Item> items; // La colecci√≥n
    private int capacidadMax;

    public Mochila(int capacidad) {
        this.items = new ArrayList<>();
        this.capacidadMax = capacidad;
    }

    public void guardar(Item i) {
        if (items.size() < capacidadMax) {
            items.add(i);
            System.out.println("Guardado: " + i);
        } else {
            System.out.println("No cabe: " + i);
        }
    }
    
    public String listar() {
        return items.toString();
    }
}
```

```java
// CLASE PRINCIPAL
public class Personaje {

    private String nombre;
    private int vida;

    private Arma armaEquipada;
    private Mochila mochila;

    public Personaje(String nombre, Arma armaInicial) {
        this.nombre = nombre;
        // Importante: Validamos que no nos pasen un arma 'null'
        if (armaInicial == null) {
            System.out.println("¬°Cuidado! Se intenta crear sin arma.");

        }
        setArmaEquipada(armaInicial);
        mochila = new Mochila(10);
    }

    public String getNombre() {
        return nombre;
    }

    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    public int getVida() {
        return vida;
    }

    public void setVida(int vida) {
        this.vida = vida;
    }

    public Arma getArmaEquipada() {
        return armaEquipada;
    }

    public void atacar() {
        // DELEGACI√ìN: Usamos el objeto interno para trabajar
        System.out.println(this.nombre + " ataca con " + this.armaEquipada.getNombre());
        System.out.println("Da√±o causado: " + this.armaEquipada.getDano());
    }

    public void cambiarArma(Arma nuevaArma) {
        setArmaEquipada(nuevaArma);
        System.out.println(this.nombre + " ahora lleva: " + getArmaEquipada().getNombre());
    }

    public void setArmaEquipada(Arma nuevoArma) {
        if (nuevoArma != null) {
            this.armaEquipada = nuevoArma;
        } else {
            Arma punyoPorDefecto = new Arma("Pu√±o", 1);
            this.armaEquipada = punyoPorDefecto;
        }
    }

    public void cogerObjeto(Item i) {
        // Delegamos en la mochila la acci√≥n de guardar
        this.mochila.guardar(i);
    }
}
```

### 1.5. Visualizaci√≥n Completa

En este diagrama mostramos **todos** los atributos para ver la estructura completa de objetos en memoria.

```mermaid
classDiagram
    class Personaje {
        - String nombre
        - int vida
        - Arma armaEquipada
        - Mochila mochila
        + Personaje(nombre, arma)
        + atacar()
        + cambiarArma(Arma)
        + cogerObjeto(Item)
    }
    class Arma {
        - String nombre
        - int dano
        + getDano()
    }
    class Mochila {
        - ArrayList~Item~ items
        - int capacidadMax
        + guardar(Item)
    }
    class Item {
        - String nombre
        - int durabilidad
    }

    Item --o Mochila : Contiene
    Personaje o-- Arma : Agregaci√≥n (Tiene una)
    Personaje *-- Mochila : Composici√≥n (Parte de √©l)
```

!!! question "üíª Momento de Pr√°ctica: El Ordenador Modular"
    Vamos a construir un PC modular. Esta vez no es una sola clase, ser√° un sistema de piezas ensambladas.

    **1. Las Piezas (Clases Componentes)**
    
    *   **Clase `Procesador`:**
        *   Atributos: `marca` (String) y `modelo` (String).
        *   Constructor y m√©todo `toString()` que devuelva algo como *"Intel i7"*.
    *   **Clase `MemoriaRAM`:**
        *   Atributos: `capacidad` (int, en GB) y `tecnologia` (String, ej: "DDR4", "DDR5").
        *   Constructor y m√©todo `toString()`.

    **2. La Torre (Clase Compuesta)**

    *   **Clase `Ordenador`:**
        *   Atributos:
            *   `cpu`: Objeto de tipo `Procesador`.
            *   `bancosRAM`: `ArrayList<MemoriaRAM>` (Aqu√≠ guardaremos los m√≥dulos).
            *   `MAX_RAM_SLOTS`: Constante `final int` (ej: 4).
        *   Constructor: Debe recibir **solo el Procesador** y crear la lista de RAM vac√≠a.

    **3. La L√≥gica de Ensamblaje**

    *   M√©todo **`void anadirMemoria(MemoriaRAM ram)`**:
        *   Comprueba si hay hueco libre (`size() < MAX_RAM_SLOTS`).
        *   Si hay hueco, a√±ade la memoria a la lista.
        *   Si no, imprime: *"¬°No quedan slots libres!"*.
    
    *   M√©todo **`void mostrarConfiguracion()`**:
        *   Imprime el procesador.
        *   Recorre la lista de RAM sumando sus capacidades.
        *   Muestra el total: *"Ordenador con [Intel i7] y [32] GB de RAM instalada"*.

    **Reto Extra:** Modifica `anadirMemoria` para que impida mezclar tecnolog√≠as. Si la primera RAM es "DDR4", no debe dejar a√±adir una "DDR5".

---

## 2. Introducci√≥n a la Herencia

La **Herencia** es el mecanismo que nos permite crear nuevas clases basadas en clases que ya existen.

Imagina que est√°s programando un videojuego con 50 tipos de enemigos distintos (Zombies, Aliens, Robots...). Todos tienen `vida`, todos se `mueven`, todos tienen `coordenadas`.

*   ¬øVas a escribir el c√≥digo de `moverse()` 50 veces? **NO**.
*   ¬øSi descubres un fallo en el movimiento, vas a corregirlo en 50 archivos? **NO**.

Aqu√≠ entra la **Herencia**:
Igual que t√∫ heredas el ADN de tus padres (no tienes que "aprender" a tener ojos, ya te vienen de f√°brica), en programaci√≥n creamos una **Clase Padre** con lo com√∫n y las **Clases Hijas** heredan su c√≥digo autom√°ticamente.

### 2.1. La Regla del "ES-UN" (Is-A)

Para saber si debes usar herencia, la frase debe tener sentido:

*   Un `Guerrero` **ES UN** `Personaje`. (Correcto: Herencia)
*   Un `Coche` **ES UN** `Motor`. (Incorrecto: Es Composici√≥n, porque *TIENE un* motor)

### 2.2. Sintaxis (`extends`) y Visibilidad (`protected`)

Para heredar usamos **`extends`**. Pero tenemos un problema: los hijos no pueden ver los atributos `private` de sus padres.

Para solucionarlo, existe un modificador de acceso dise√±ado espec√≠ficamente para la herencia: **`protected`**.
Este nivel de visibilidad act√∫a como un punto intermedio entre la privacidad total y la exposici√≥n p√∫blica:

| Modificador | Alcance y Descripci√≥n |
| :--- | :--- |
| **`public`** | Visible desde **cualquier clase** de la aplicaci√≥n. |
| **`protected`** | Visible para las clases del **mismo paquete** y para sus **subclases** (hijas), independientemente de donde est√©n. |
| **`private`** | Visible √∫nicamente dentro de la **propia clase** (ni siquiera los hijos pueden acceder). |


!!! tip "¬øCu√°ndo usar `protected`?"
    Aunque `protected` es √∫til para la herencia, **no abuses de √©l**.
    
    Por defecto, intenta mantener tus atributos `private` y usa **Getters/Setters** (p√∫blicos o protegidos) si los hijos necesitan acceder. Usa `protected` en atributos solo cuando sea estrictamente necesario para el dise√±o o rendimiento.

```java
// CLASE PADRE (Superclase)
public class Personaje {
    protected String nombre; // Protected para que los hijos lo puedan usar
    protected int vida;

    public Personaje(String nombre, int vida) {
        this.nombre = nombre;
        this.vida = vida;
    }

    public void saludar() {
        System.out.println("Hola, soy un personaje gen√©rico.");
    }
}
```

```java
// CLASE HIJA (Subclase)
public class Guerrero extends Personaje {
    private int furia; // Atributo exclusivo del hijo

    // EL CONSTRUCTOR: La Regla de los Cimientos
    public Guerrero(String nombre, int vida, int furia) {
        // 1¬∫ Construimos al padre (Cimientos)
        super(nombre, vida); 
        // 2¬∫ Construimos al hijo (Decoraci√≥n)
        this.furia = furia;
    }
}
```

!!! warning "Importante: super()"
    La llamada a **`super()`** debe ser SIEMPRE la **primera l√≠nea** del constructor del hijo. No puedes decorar la casa si no has puesto los cimientos antes.

!!! tip "Curiosidad: ¬øHerencia M√∫ltiple?"
    En Java, una subclase **SOLO puede tener un PADRE** (`extends`). No existe la herencia m√∫ltiple de clases (como en C++ o Python).
    
    Esto se hace para evitar conflictos (el "Problema del Diamante"). Sin embargo, Java compensa esto permitiendo implementar **m√∫ltiples Interfaces**.

### 2.3. Sobreescritura de M√©todos (`@Override`)

¬øY si el hijo quiere hacer las cosas de forma diferente a su padre?
El `Guerrero` hereda `saludar()`, pero quiere saludar gritando.

Podemos **reescribir** el m√©todo usando la etiqueta **`@Override`**.

```java
public class Guerrero extends Personaje {
    // ... constructor ...

    @Override
    public void saludar() {
        // Opci√≥n A: Borr√≥n y cuenta nueva (Ignoramos al padre)
        System.out.println("¬°GRRR! SOY " + this.nombre + " Y TE APLASTAR√â.");
        
        // Opci√≥n B: Ampliar lo que hace el padre
        // super.saludar(); // Llamar√≠a al "Hola..." original
        // System.out.println("...pero tengo mal genio.");
    }
}
```

### 2.4. Diagrama de Herencia

En UML, la herencia se representa con una **flecha de l√≠nea continua y punta triangular hueca** que va del Hijo al Padre.

```mermaid
classDiagram
    class Personaje {
        # String nombre
        # int vida
        + saludar()
    }
    
    class Guerrero {
        - int furia
        + saludar()
    }
    
    class Mago {
        - int mana
        + lanzarHechizo()
    }

    Personaje <|-- Guerrero : Es un
    Personaje <|-- Mago : Es un
```

*(Nota: El s√≠mbolo `#` representa `protected` en los diagramas).*

!!! question "üíª Momento de Pr√°ctica: El Reino Animal"
    Vamos a crear una peque√±a jerarqu√≠a biol√≥gica.

    1.  Crea una clase **`Animal`** con atributos `protected nombre` y `edad`.
        *   M√©todo `hacerSonido()` que imprima: *"..."* (sonido gen√©rico).
    2.  Crea la clase **`Perro`** que hereda de `Animal`.
        *   `@Override` `hacerSonido()` -> *"¬°Guau!"*.
    3.  Crea la clase **`Gato`** que hereda de `Animal`.
        *   `@Override` `hacerSonido()` -> *"¬°Miau!"*.
    4.  **En el Main:**
        *   Crea un Perro y un Gato.
        *   Haz que ambos "hablen".
        *   **Prueba Curiosa:** Intenta hacer `Animal a = new Perro(...)`. ¬øFunciona? (Spoiler: S√≠, es el principio del Polimorfismo).

---

## 3. Clases Abstractas

Hasta ahora, nuestras clases serv√≠an para crear objetos (`new Guerrero()`). Pero a veces, necesitamos definir un concepto que es puramente estructural y no deber√≠a existir por s√≠ solo.

**Concepto Abstracto vs Implementaci√≥n Concreta:**
Piensa en la ingenier√≠a. T√∫ sabes lo que es un **"Veh√≠culo"** (tiene motor, ruedas, transporta gente).

*   Pero t√∫ no puedes ir a un concesionario y decir: *"Deme un Veh√≠culo, a secas"*.
*   El vendedor te dir√°: *"¬øQuiere un Coche? ¬øUna Moto? ¬øUn Cami√≥n?"*.

"Veh√≠culo" es un concepto abstracto. No se puede fabricar. Solo sirve de base para crear cosas reales como "Coche" o "Moto".

### 3.1. Definici√≥n (`abstract`)

En Java, usamos la palabra clave **`abstract`** para impedir que una clase se pueda instanciar.

```java
public abstract class Figura {
    protected String color; // Un atributo com√∫n m√°s l√≥gico para una figura
    
    public Figura(String color) {
        this.color = color;
    }
}
```

*   **Efecto inmediato:** `new Figura("Rojo")` dar√° **ERROR DE COMPILACI√ìN**.
*   **Utilidad:** Solo podemos usarla como padre (`extends`) para crear clases √∫tiles como `Circulo` o `Rectangulo`.

### 3.2. M√©todos Abstractos (El Contrato)

Si definimos una "Figura", sabemos que todas las figuras tienen un **√Årea**. Pero, ¬øc√≥mo se calcula el √°rea de "una figura gen√©rica"?
¬°No se puede! Depende de si es redonda o cuadrada.

Aqu√≠ usamos un **M√©todo Abstracto**: Definimos el **QU√â** pero dejamos el **C√ìMO** vac√≠o.

```java
public abstract class Figura {
    protected String color;

    public Figura(String color) {
        this.color = color;
    }

    // M√âTODO ABSTRACTO: No tiene llaves {}. Termina en "punto y coma".
    // "Prometo que cualquier hijo m√≠o sabr√° calcular su √°rea, pero yo no s√© c√≥mo".
    public abstract double calcularArea();
}
```

**La Regla de Oro:**
Si heredas de una clase abstracta, est√°s **OBLIGADO** a implementar sus m√©todos abstractos (darles c√≥digo). Si no lo haces, t√∫ tambi√©n ser√°s abstracto.

### 3.3. Ejemplo: Geometr√≠a

```java
// CLASE HIJA 1
public class Circulo extends Figura {
    private double radio;

    public Circulo(String color, double radio) {
        super(color);
        this.radio = radio;
    }

    @Override
    public double calcularArea() {
        return Math.PI * radio * radio;
    }
}
```

```java
// CLASE HIJA 2
public class Rectangulo extends Figura {
    private double base, altura;

    public Rectangulo(String color, double base, double altura) {
        super(color);
        this.base = base;
        this.altura = altura;
    }

    @Override
    public double calcularArea() {
        return base * altura;
    }
}
```

```java
// CLASE HIJA 3
public class Triangulo extends Figura {
    private double base, altura;

    public Triangulo(String color, double base, double altura) {
        super(color);
        this.base = base;
        this.altura = altura;
    }

    @Override
    public double calcularArea() {
        return (base * altura) / 2;
    }
}
```

### 3.4. Diagrama UML

En los diagramas de clases, las clases abstractas y los m√©todos abstractos se representan en *cursiva* (o con la etiqueta `<<abstract>>`).

```mermaid
classDiagram
    class Figura {
        <<abstract>>
        # String color
        + Figura(String color)
        + calcularArea()* double
    }
    
    class Circulo {
        - double radio
        + calcularArea() double
    }
    
    class Rectangulo {
        - double base
        - double altura
        + calcularArea() double
    }

    Figura <|-- Circulo
    Figura <|-- Rectangulo
```

*(Nota: El asterisco `*` o la cursiva en `calcularArea()` indica que es abstracto).*

### 3.5. Clases y M√©todos Finales (`final`)

Justo lo opuesto a `abstract` es **`final`**.

*   **Clase `final`:** "Est√©ril". Nadie puede heredar de ella. (Ej: `String` es `final` por seguridad).
*   **M√©todo `final`:** "Intocable". Nadie puede sobreescribirlo (`@Override`).

```java
// Ejemplo: Una clase que no queremos que nadie modifique ni extienda
public final class ConstantesFisicas {
    public static final double GRAVEDAD = 9.81;
}

// ERROR DE COMPILACI√ìN: No se puede heredar de una clase final
// public class MiFisica extends ConstantesFisicas { ... }
```

!!! question "üíª Momento de Pr√°ctica: Gesti√≥n de N√≥minas"
    Vamos a crear un sistema de pago para una empresa.
    
    1.  Clase Abstracta **`Empleado`**:
        *   Atributos: `nombre`, `dni`.
        *   M√©todo Abstracto: **`double calcularSueldo()`**.
        *   M√©todo Normal: `toString()` que devuelva el nombre.
    2.  Hija **`EmpleadoAsalariado`**:
        *   Tiene `sueldoBase` (fijo) y `antiguedad` (a√±os).
        *   Sueldo = `sueldoBase` + (100 * `antiguedad`).
    3.  Hija **`Freelance`**:
        *   Tiene `precioHora` y `horasTrabajadas`.
        *   Sueldo = `precioHora` * `horasTrabajadas`.
    4.  **Main (Polimorfismo puro):**
        *   Crea un `ArrayList<Empleado>`.
        *   A√±ade un Asalariado y un Freelance.
        *   Recorre la lista y suma cu√°nto dinero total tiene que pagar la empresa este mes.

---

## 4. Interfaces

Las **Interfaces** llevan la abstracci√≥n al siguiente nivel. Si una Clase Abstracta define **QU√â ERES** (Identidad), una Interfaz define **QU√â PUEDES HACER** (Capacidad).

### 4.1. Met√°fora: El Mando de la Consola

Imagina el mando de una videoconsola.

*   Tiene unos botones definidos: **X**, **O**, **Tri√°ngulo**, **Cuadrado**.
*   Si juegas al **FIFA**, al pulsar **X** haces un *Pase*.
*   Si juegas al **Call of Duty**, al pulsar **X** haces un *Salto*.

El mando (Interfaz) impone **qu√© botones existen**, pero no **qu√© hacen**.
La clase concreta (el juego) es quien decide c√≥mo reaccionar a esos botones.

### 4.2. Diferencias Clave

| Caracter√≠stica | Clase Abstracta | Interfaz |
| :--- | :--- | :--- |
| **Concepto** | **Identidad** (ADN). "Soy un Animal". | **Habilidad** (T√≠tulo). "S√© Nadar". |
| **Relaci√≥n** | Padres/Hijos (Jerarqu√≠a Vertical). | Contrato (Conexi√≥n Horizontal). |
| **Atributos** | Puede tener variables normales. | Solo constantes (`public static final`). |
| **Herencia** | Simple (Solo un padre). | **M√∫ltiple** (Puedes tener muchas habilidades). |

### 4.3. Ejemplo: GPS Universal (`Localizable`)

Imagina una App de mapas. Necesita mostrar cosas en el mapa.
No solo coches. Tambi√©n personas, mascotas con collar GPS, o incluso edificios.
No tienen NADA en com√∫n (no son familia), pero todos son **Localizables**.

Primero, vamos a definir una clase que almacene las coordenadas.

```java
public class Coordenadas {
    
    public double latitud, longitud;

    public Coordenadas(double latitud, double longitud) {
        this.latitud = latitud;
        this.longitud = longitud;
    }
}
```

Ahora, vamos a definir la interfaz `Localizable`. Estar√° implementada por todas las clases que quieran ser localizables y usaremos el objeto `Coordenadas` para almacenar las coordenadas en cada clase.

```java
// 1. Definimos la CAPACIDAD (Interfaz)
public interface Localizable {
    // "Quien firme esto, debe saber decirme d√≥nde est√°"
    double getLatitud();
    double getLongitud();
}

```

Podemos usar la interfaz `Localizable` para implementar la localizaci√≥n en clases abstractas.

```java
public abstract class Vehiculo implements Localizable {

    protected Coordenadas gps;

    /** Simplificamos el c√≥digo */

    @Override
    public double getLatitud() {
        return this.gps.lat;
    }

    @Override
    public double getLongitud() {
        return this.gps.lon;
    }

}
```

Podemos usar la interfaz `Localizable` para implementar la localizaci√≥n en clases concretas.

```java
public class Usuario implements Localizable {

    private String nombre;
    private int edad;
    private Coordenadas movil;

    /** Simplificamos el c√≥digo */

    public Usuario(String nombre, int edad, Coordenadas movil) {
        this.nombre = nombre;
        this.edad = edad;
        this.movil = movil;
    }

    @Override
    public double getLatitud() {
        return this.movil.lat;
    }

    @Override
    public double getLongitud() {
        return this.movil.lon;
    }

}
```

```java
public class Perro implements Localizable {

    private String nombre;
    private Coordenadas collar;

    /** Simplificamos el c√≥digo */

    public Perro(String nombre, Coordenadas collar) {
        this.nombre = nombre;
        this.collar = collar;
    }

    @Override
    public double getLatitud() {
        return this.collar.lat;
    }

    @Override
    public double getLongitud() {
        return this.collar.lon;
    }

}
```

Aqu√≠ tenemos un ejemplo de uso en el `main`:

```java
public class MainInterfaces {

    public static void main(String[] args) {

        Coordenadas localizacion = new Coordenadas(39.67, -0.25);

        Perro perro = new Perro("Sparky", localizacion);
        Usuario usuario = new Usuario("Dulcinea del Toboso", 18, localizacion);

        System.out.println("Mi perro est√° en " + perro.getLatitud() + " " +  perro.getLongitud());
        System.out.println("Dulcinea del Toboso est√° en  " + usuario.getLatitud() + " " +  usuario.getLongitud());

    }
}
```

### 4.4. Diagrama UML

En UML, la relaci√≥n **"implementa una interfaz"** (Realizaci√≥n) se dibuja con una **l√≠nea discontinua y punta triangular hueca**.

```mermaid
classDiagram
    class Localizable {
        <<interface>>
        + getLatitud()
        + getLongitud()
    }

    class Vehiculo {
        <<abstract>>
        + getLatitud()
        + getLongitud()
    }

    class Usuario {
        + getLatitud()
        + getLongitud()
    }
    
    class Perro {
        + getLatitud()
        + getLongitud()
    }

    Localizable <|.. Vehiculo : Implements
    Localizable <|.. Usuario : Implements
    Localizable <|.. Perro : Implements
```

!!! tip "Poder Ilimitado: Implementar M√∫ltiples Interfaces"
    A diferencia de la herencia de clases (`extends`), donde solo puedes tener **un padre**, en Java puedes implementar **tantas interfaces como quieras**.
    
    Solo tienes que separarlas por comas:
    `public class SuperHeroe implements Volador, SuperFuerza, IdentidadSecreta { ... }`
    
    ¬°Eso s√≠! Tienes que escribir el c√≥digo de **TODOS** los m√©todos de **TODAS** las interfaces.

!!! question "üíª Momento de Pr√°ctica: La Casa Dom√≥tica"
    Vamos a crear los dispositivos inteligentes de una casa.
    
    1.  **La Interfaz:** Crea `Controlable` con m√©todos `void encender()` y `void apagar()`.
    2.  **Las Clases:** Crea `Televisor`, `AireAcondicionado` y `Persiana` que implementen `Controlable`.
        *   *Piensa* en qu√© atributo necesitas para indicar si un dispositivo est√° encendido o apagado.
        *   *Detalle:* El televisor al encenderse dice: "Bienvenido a Netflix".
        *   *Detalle:* El aire al apagarse dice: "Cerrando aspas...".
    3.  **La Prueba:** En el `main`, crea un objeto de cada uno. Enci√©ndelos y ap√°galos.
    4.  **Reflexi√≥n:** F√≠jate que aunque los m√©todos se llaman igual, cada objeto hace algo distinto (uno muestra logos, otro mueve aspas). Eso es gracias a la interfaz.

---

## 5. Polimorfismo

El **Polimorfismo** ("muchas formas") es la magia real de la POO. Nos permite tratar a objetos diferentes de forma gen√©rica, pero conservando su comportamiento √∫nico.

### 5.1. Met√°fora: La Caja M√°gica

Imagina que tienes una caja etiquetada como **"Personaje"**.

*   Dentro de la caja metes a un **Guerrero**.
*   T√∫, desde fuera, solo ves la etiqueta "Personaje".
*   Si le gritas a la caja *"¬°ATACA!"*, lo que saldr√° de dentro es un **ESPADAZO** (comportamiento de Guerrero), aunque t√∫ trataras la caja como algo gen√©rico.

**Concepto Clave:**

*   **Tipo de la Variable (La Caja):** Define qu√© m√©todos PUEDES llamar.
*   **Tipo del Objeto (El Contenido):** Define C√ìMO se ejecutan esos m√©todos.

### 5.2. Ligadura Din√°mica (Dynamic Binding)

```java
// Creamos un ARRAYLIST de la clase padre (La Caja)
ArrayList<Personaje> grupo = new ArrayList<>();

// Guardamos objetos HIJOS (El Contenido)
grupo.add(new Guerrero("Conan", 100, 5, 20));
grupo.add(new Mago("Gandalf", 80, 10, 50));

// Creamos un enemigo dummy
Personaje enemigo = new Orco("Orokhur", 200, 1, 8);

// BUCLE POLIM√ìRFICO:
// Tratamos a todos como "Personaje", pero cada uno reacciona a su manera.
for (Personaje p : grupo) {
    p.atacar(enemigo); // JAVA VE: Guerrero -> Espadazo, Mago -> Fuego...
}
```

Java decide **en tiempo de ejecuci√≥n** qu√© c√≥digo ejecutar. Esto se llama **Ligadura Din√°mica**.

### 5.3. Trasteando con la Herencia: Casting y `instanceof`

A veces, tienes un `Personaje` (caja gen√©rica) pero sabes que dentro hay un `Guerrero` y quieres usar su m√©todo especial `gritoDeGuerra()` (que el Mago no tiene).

Intentarlo directamente da error:
```java
Personaje p = grupo.get(0); // Recuperamos al primero (Sabemos que es Conan)
// p.gritoDeGuerra(); // ERROR: La clase Personaje no tiene ese m√©todo.
```

Para solucionarlo, necesitamos hacer **Casting** (destapar la caja y confirmar qu√© es). Pero ¬°cuidado! Si te equivocas, el programa explota. Para estar seguros, usamos el "esc√°ner de rayos X": **`instanceof`**.

```java
if (p instanceof Guerrero) {
    // Confirmado: Es un guerrero. Hacemos Downcasting seguro.
    Guerrero g = (Guerrero) p;
    g.gritoDeGuerra(); // ¬°AHORA S√ç!
}
```

!!! question "üíª Reto Final de Unidad: El Zool√≥gico Interactivo ü¶Åüê¨üê∂"
    Vamos a crear un simulador de zool√≥gico con gesti√≥n de energ√≠a.

    1.  **Clase Abstracta `Animal`:**
        *   Atributos: `nombre`, `energia` (empieza en 50).
        *   M√©todo `jugar(int gasto)`: Resta energ√≠a e imprime *"[Nombre] est√° jugando... Energ√≠a restante: [X]"*.
        *   M√©todo Abstracto **`comer(String comida)`**: Cada animal recupera energ√≠a de forma distinta seg√∫n lo que coma. Si no quiere la comida, muestra rechazo con un mensaje.
    2.  **Interfaz `Trucos`:**
        *   M√©todo `hacerTruco()`: Muestra un mensaje especial.
    3.  **Las Especies:**
        *   **`Leon`:** Solo come "Carne" (+100 de energ√≠a). Si le das otra cosa, se enfada y pierde 10. *No hace trucos*.
        *   **`Delfin`:** Come "Peces" (+50) y "Calamar" (+80). Implementa `Trucos`: *"¬°Hace un salto mortal hacia atr√°s!"* y resta 10 de energ√≠a.
        *   **`Perro`:** Come de todo ("Carne" +50, "Pienso" +30). Implementa `Trucos`: *"¬°Da la patita y rueda!"* y resta 5 de energ√≠a.
    4.  **El Show (Main):**
        *   Crea un `ArrayList<Animal>` con uno de cada.
        *   **Bucle del Show:**
            1.  Haz que todos **jueguen** (gastan 20 de energ√≠a).
            2.  Alim√©ntalos a todos con "Carne". (Observa c√≥mo el Delf√≠n no la querr√°).
            3.  Si el animal sabe hacer **trucos** (`instanceof`), ¬°que act√∫e para el p√∫blico!

---

### 5.4. Sobreescritura de Comparadores (Igualdad y Orden)

En Java, a menudo necesitamos saber si dos objetos son "iguales" o cu√°l va antes en una lista (ordenar).
Por defecto, `==` solo compara si son **el mismo objeto en memoria**, no si tienen los mismos datos.

#### 5.4.1. Igualdad de Contenido (`equals`)

Para comparar el **contenido**, debemos sobreescribir el m√©todo `equals` y `hashCode`.

```java
@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || getClass() != obj.getClass()) return false;

    Personaje otro = (Personaje) obj;
    // Decidimos que dos personajes son iguales si tienen el mismo nombre
    return this.nombre.equals(otro.nombre);
}

@Override
public int hashCode() {
    // Si dos objetos son iguales, DEBEN tener el mismo hashCode.
    return this.nombre.hashCode();
}
```

!!! tip "El contrato de `equals` y `hashCode`"
    1.  **`equals()`**: Define cu√°ndo dos objetos son l√≥gicamente "el mismo".
    2.  **`hashCode()`**: Devuelve un n√∫mero entero que representa al objeto (como una huella dactilar r√°pida).
    
    **Regla de Oro:** Siempre que sobreescribas `equals`, **DEBES** sobreescribir `hashCode`.
    ¬øPor qu√©? Porque colecciones como `HashSet` o `HashMap` usan primero el `hashCode` para buscar r√°pido. Si dos objetos son iguales pero tienen `hashCode` distinto, estas colecciones fallar√°n y creer√°n que son objetos diferentes.


#### 5.4.2. Orden Natural (`Comparable`)

Si queremos poder ordenar una lista de personajes con `Collections.sort(lista)`, nuestra clase debe implementar la interfaz `Comparable<T>` y su m√©todo `compareTo`.

**Ejemplo 1: Ordenar por Nombre (Texto)**

```java
public class Personaje implements Comparable<Personaje> {
    // ... codigo ...

    @Override
    public int compareTo(Personaje o) {
        // Orden alfab√©tico por nombre (String ya implementa compareTo)
        return this.nombre.compareTo(o.nombre);
    }
}
```

**Ejemplo de Uso:**

```java
ArrayList<Personaje> lista = new ArrayList<>();
lista.add(new Guerrero("Link", ...));
lista.add(new Mago("Gandalf", ...));
lista.add(new Guerrero("Aragorn", ...));

// Al llamar a sort, Java usa tu m√©todo compareTo para ordenar
Collections.sort(lista);

for (Personaje p : lista) {
    System.out.println(p.getNombre()); // Salida: Aragorn, Gandalf, Link
}
```

**Ejemplo 2: Ordenar por Nivel (Num√©rico)**

Si preferimos ordenar por su poder (nivel), comparamos enteros.

```java
@Override
public int compareTo(Personaje o) {
    // Orden num√©rico por nivel
    return Integer.compare(this.nivel, o.nivel); 
}
```

!!! tip "Comparadores de tipos `Integer`, `Double` y `String`"
    Java ya tiene implementados los comparadores para estos tipos.
    *   `Integer.compare(a, b)`
    *   `Double.compare(a, b)`
    *   `String.compare(a, b)`

--- 

## 6. Ejemplo Completo de Integraci√≥n

A continuaci√≥n, tienes un ejemplo de c√≥digo completo que integra **Herencia, Clases Abstractas, Interfaces y Polimorfismo**.
Puedes copiar cada bloque en un archivo separado para probarlo.

**Escenario:** Un peque√±o juego RPG.

### 6.1. La Interfaz (Capacidad)

```java
// Archivo: Atacable.java
public interface Atacable {
    void recibirDano(int cantidad);
}
```

### 6.2. La Clase Abstracta (Identidad Base)

```java
// Archivo: Personaje.java
public abstract class Personaje implements Atacable, Comparable<Personaje> {

    protected String nombre;
    protected int vida;
    protected int nivel;

    public Personaje(String nombre, int vida, int nivel) {
        this.nombre = nombre;
        this.vida = vida;
        this.nivel = nivel;
    }

    public abstract void atacar(Personaje objetivo);

    @Override
    public void recibirDano(int cantidad) {
        this.vida -= cantidad;
        if (this.vida < 0) this.vida = 0;
        System.out.println(this.nombre + " recibe " + cantidad + " de da√±o. Vida restante: " + this.vida);
    }

    public boolean estaVivo() {
        return this.vida > 0;
    }

    public String getNombre() { return nombre; }

    // --- M√âTODOS DE IGUALDAD Y ORDEN ---

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Personaje other = (Personaje) obj;
        return this.nombre.equals(other.nombre);
    }

    @Override
    public int hashCode() {
        return this.nombre.hashCode();
    }

    @Override
    public int compareTo(Personaje o) {
        // Orden alfab√©tico por nombre
        return this.nombre.compareTo(o.nombre);
    }
}
```

### 6.3. Las Clases Concretas (Implementaci√≥n)

```java
// Archivo: Guerrero.java
public class Guerrero extends Personaje {
    private int furia;

    public Guerrero(String nombre, int vida, int nivel, int furia) {
        super(nombre, vida, nivel);
        this.furia = furia;
    }

    @Override
    public void atacar(Personaje objetivo) {
        int dano = this.nivel * 2 + this.furia;
        System.out.println(this.nombre + " lanza un ESPADAZO BRUTAL a " + objetivo.getNombre());
        objetivo.recibirDano(dano);
    }

    public void gritoDeGuerra() {
        System.out.println(this.nombre + ": ¬°¬°GRRRR!!");
    }
}
```

```java
// Archivo: Mago.java
public class Mago extends Personaje {

    private int mana;

    public Mago(String nombre, int vida, int nivel, int mana) {
        super(nombre, vida, nivel);
        this.mana = mana;
    }

    @Override
    public void atacar(Personaje objetivo) {
        if (this.mana >= 10) {
            int dano = this.nivel * 3; // El mago pega m√°s fuerte
            this.mana -= 10;
            System.out.println(this.nombre + " lanza BOLA DE FUEGO a " + objetivo.getNombre());
            objetivo.recibirDano(dano);
        } else {
            System.out.println(this.nombre + " no tiene man√° y golpea con el bast√≥n (puf...)");
            objetivo.recibirDano(1);
        }
    }
}
```

```java
// Archivo: Orco.java
public class Orco extends Personaje {

    private int rabia;

    public Orco(String nombre, int vida, int nivel, int rabia) {
        super(nombre, vida, nivel);
        this.rabia = rabia;
    }

    @Override
    public void atacar(Personaje objetivo) {
        if (this.vida < 10) {
            int dano = this.nivel * 4 + rabia;
            System.out.println(this.nombre + " ataca con FURIA " + objetivo.getNombre());
            objetivo.recibirDano(dano);
        } else {
            objetivo.recibirDano(this.nivel);
        }
    }
}
```

### 6.4. El Main (Polimorfismo en Acci√≥n)

```java
// Archivo: JuegoRPG.java
import java.util.ArrayList;

public class JuegoRPG {
    public static void main(String[] args) {
        ArrayList<Personaje> equipo = new ArrayList<>();

        // Polimorfismo: Guardamos Hijos en variables Padre (lista)
        equipo.add(new Guerrero("Conan", 150, 5, 100));
        equipo.add(new Mago("Gandalf", 80, 10, 200));

        // Enemigo dummy para probar
        Guerrero enemigo = new Orco("Orco Feo", 200, 3, 8);

        System.out.println("--- EMPIEZA LA BATALLA ---");

        // Bucle Polim√≥rfico
        for (Personaje p : equipo) {
            p.atacar(enemigo); // Java decide qu√© atacar() usar din√°micamente

            // Uso de instanceof para acceder a m√©todos exclusivos
            if (p instanceof Guerrero) {
                ((Guerrero) p).gritoDeGuerra(); // Downcasting seguro
            }
        }
    }
}
```

### 6.5. Diagrama UML Completo del Juego de Rol

```mermaid
classDiagram
    class Atacable {
        <<interface>>
        + recibirDano(int cantidad)
    }

    class Personaje {
        <<abstract>>
        # String nombre
        # int vida
        # int nivel
        + Personaje(nombre, vida, nivel)
        + atacar(Personaje objetivo)*
        + recibirDano(int cantidad)
        + estaVivo() boolean
    }

    class Guerrero {
        - int furia
        + Guerrero(nombre, vida, nivel, furia)
        + atacar(Personaje objetivo)
        + gritoDeGuerra()
    }

    class Mago {
        - int mana
        + Mago(nombre, vida, nivel, mana)
        + atacar(Personaje objetivo)
    }

    Atacable <|.. Personaje : Implements
    Personaje <|-- Guerrero : Extends
    Personaje <|-- Mago : Extends
```

